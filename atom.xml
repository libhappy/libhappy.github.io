<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[LibHappy]]></title>
  <subtitle><![CDATA[Happy Life, Happy Coding.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://libhappy.com/"/>
  <updated>2016-04-14T09:27:05.171Z</updated>
  <id>https://libhappy.com/</id>
  
  <author>
    <name><![CDATA[Arthur]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[普林斯顿算法（4.5）最短祖先路径（SAP）算法及优化]]></title>
    <link href="https://libhappy.com/2016/04/algs-4.5/"/>
    <id>https://libhappy.com/2016/04/algs-4.5/</id>
    <published>2016-04-14T05:18:29.000Z</published>
    <updated>2016-04-14T09:27:05.171Z</updated>
    <content type="html"><![CDATA[<p>在有向图（Digraph）中，由一个节点（Vertex）沿着边（Edge）可以到达的节点称为其 ancestor（祖先）。当两个不同节点拥有一个共同 ancestor 时，该 ancestor 称这两个节点的 Common Ancestor （共同祖先），Shortest Ancestral Path （SAP，最短祖先路径）即所有 common ancestor 中到两个节点路径之和最短的一个及其对应的路径。</p>
<a id="more"></a>
<!--toc-->
<p>SAP 算法在许多领域都有应用，比如在生物进化学中，所有生物的进化历程可以概括为一个无环有向图（参见 <a href="https://en.wikipedia.org/wiki/Tree_of_life_%28biology%29" target="_blank" rel="external">维基百科:Tree of life(biology)</a>），那么 SAP 算法可以在该有向图中找出两种生物的最近共同祖先。
<div class="figure center nocaption"><a class="fancybox" href="https://c2.staticflickr.com/2/1622/26328018862_a7ab383659_o.png" title="Tree of Life" target="_blank" rel="external"><img class="fig-img" src="https://farm2.staticflickr.com/1622/26328018862_e0b5c90c56_z.jpg" alt="Tree of Life"></a></div></p>
<h1 id="算法简介及API">算法简介及API</h1><h2 id="辅助类">辅助类</h2><p>以下为提供的辅助类：</p>
<ul>
<li>Digraph (有向图类)</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:right">public class Digraph</th>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right"></td>
<td style="text-align:left">Digraph(int V)</td>
<td style="text-align:left">初始化有 V 个节点的 Digraph</td>
</tr>
<tr>
<td style="text-align:right"></td>
<td style="text-align:left">Digraph(In in)</td>
<td style="text-align:left">从输入初始化 Digraph</td>
</tr>
<tr>
<td style="text-align:right">int</td>
<td style="text-align:left">V()</td>
<td style="text-align:left">返回 Digraph 的节点个数 V</td>
</tr>
<tr>
<td style="text-align:right">int</td>
<td style="text-align:left">E()</td>
<td style="text-align:left">返回 Digraph 的边个数 E</td>
</tr>
<tr>
<td style="text-align:right">void</td>
<td style="text-align:left">addEdge(int v, int w)</td>
<td style="text-align:left">添加一条从 v 指向 w 的边</td>
</tr>
<tr>
<td style="text-align:right">Iterable<integer></integer></td>
<td style="text-align:left">adj(int v)</td>
<td style="text-align:left">返回节点 v 的所有指出节点（此例中即为父节点）</td>
</tr>
<tr>
<td style="text-align:right">Digraph</td>
<td style="text-align:left">reverse()</td>
<td style="text-align:left">返回反转所有边后的 Digraph</td>
</tr>
</tbody>
</table>
<ul>
<li>BreadthFirstSearchPath (利用广度搜索的最短路径类)</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:right">public class BreadthFirstSearchPath</th>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right"></td>
<td style="text-align:left">BreadthFirstSearchPath(Digraph G, int s)</td>
<td style="text-align:left">初始化类</td>
</tr>
<tr>
<td style="text-align:right">boolean</td>
<td style="text-align:left">hasPathTo(int v)</td>
<td style="text-align:left">从起点 s 是否能够到达 v</td>
</tr>
<tr>
<td style="text-align:right">Iterable<integer></integer></td>
<td style="text-align:left">pathTo(int v)</td>
<td style="text-align:left">返回从起点 s 到节点 v 的路径</td>
</tr>
<tr>
<td style="text-align:right">int</td>
<td style="text-align:left">disTo(int v)</td>
<td style="text-align:left">返回从起点 s 到节点 v 的路径长度*</td>
</tr>
</tbody>
</table>
<p>*以下使用 <code>distance(v -&gt; s)</code> 代表方法 <code>BreadthFirstSearchPath(G, v).disTo(s)</code></p>
<h2 id="SAP">SAP</h2><table>
<thead>
<tr>
<th style="text-align:right">public class SAP</th>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right"></td>
<td style="text-align:left">SAP(Digraph G)</td>
<td style="text-align:left">初始化类</td>
</tr>
<tr>
<td style="text-align:right">int</td>
<td style="text-align:left">length(int v, int w)</td>
<td style="text-align:left">v 与 w 之间的 SAP 路径长度（不存在返回 -1）</td>
</tr>
<tr>
<td style="text-align:right">int</td>
<td style="text-align:left">ancestor(int v, int w)</td>
<td style="text-align:left">v 与 w 之间的 SAP 祖先节点（不存在返回 -1）</td>
</tr>
<tr>
<td style="text-align:right">int</td>
<td style="text-align:left">length(Iterable<integer> v, Iterable<integer> w)</integer></integer></td>
<td style="text-align:left">节点集v 与 节点集w 之间的 SAP 路径长度（不存在返回 -1）</td>
</tr>
<tr>
<td style="text-align:right">int</td>
<td style="text-align:left">ancestor(Iterable<integer> v, Iterable<integer> w)</integer></integer></td>
<td style="text-align:left">节点集v 与 节点集w 之间的 SAP 祖先节点（不存在返回 -1）</td>
</tr>
</tbody>
</table>
<p>SAP 类需要在初始化时接受一个Digraph类的实例，length() 及 ancestor() 方法分别接收两个参数（节点或节点集）并返回找到的 SAP 最短路径长度及节点，当不存在该 common ancestor 时返回 -1。当接收的参数为节点集时，返回值为节点集 v 中任一节点与节点集 w 中任一节点的所有 SAP 中长度最小的一个。</p>
<h1 id="全局遍历">全局遍历</h1><p>在 Digraph 中寻找两个节点 v， w 之间的 SAP 最简单的粗暴的方式就是直接遍历。
类 <code>BreadthFirstSearchPath(Digraph G, int v)</code> 初始化后，通过方法 <code>hasPathTo(int s)</code> 能够判断是否有从 v 到 s 的路径，方法 <code>disTo(int s)</code> 能够得到从 v 到 s 的路径长度。
当某个节点同时存在从 v 与 w 出发的路径时，则该节点为 common ancestor，遍历 Digraph 中所有节点找出所有的 common ancestor，并找出其中到 v 与 w 路径之和最短的即可。</p>
<p>该方法能够找出所需的 SAP ，但遍历 Digraph 中的所有节点运行效率极低。</p>
<h1 id="镜面法">镜面法</h1><p>参考物理中寻找通过镜面反射的最短光路问题。将 SAP 节点称为 a ，那么在 <code>Digraph</code> 中 <code>distance(v -&gt; a) + distance(w -&gt; a)</code> 最小等价于 <code>Digraph</code> 中 <code>distance(v -&gt; a)</code> 与 <code>Digraph.reverse</code> 中 <code>distance(a&#39; -&gt; w&#39;)</code> 之和最小。</p>
<p>建立一个大小为 2*V 的 <code>NewDigraph</code>，其中 V 个节点代表 <code>Digraph</code> 中的节点（s），并按照 <code>Digraph</code> 中的边连接；另外 V 个节点代表 <code>Digraph.reverse</code> 中的节点（s’），并按照 <code>Digraph.reverse</code> 中的边连接（镜子中的虚像，边的连接方向相反）。然后将代表 <code>Digraph</code> 中每个节点 s 与代表 <code>Digraph.reverse</code> 中的对应节点 s’ 连接起来 <code>NewDigraph.addEdge(s -&gt; s&#39;)</code> (将实像与虚像相连)。这样，当寻找 v 与 w 的 SAP 时，在 <code>NewDigraph</code> 中寻找 v -&gt; w’ 的最短路径即可（Breadth First Search），而该最短路径比 SAP 路径长 1 （多 a -&gt; a’ 一步），SAP 路径的 common ancestor 即为穿过镜子的点 a (在路径中表现为 a 与 a’ 相连，且区分实像与虚像点)。</p>
<p>该方法实现起来简单，但弊端十分明显。其将有向图节点数增加了一倍（V -&gt; 2*V） 边数增加了 V+E （E -&gt; E+E+V）,那么程序所占用的内存也要增加不止一倍。更为重要的是，虽然在这个扩大的有向图中能够通过 BFS 找到 SAP 但需要遍历的节点与边数大大增加，程序的运行效率依旧很低。</p>
<h1 id="从起点遍历">从起点遍历</h1><p>既然要寻找以 v 和 w 为起点的路径，那么直接从 v 和 w 开始遍历会更为有利。搜索的执行步骤如下：</p>
<ol>
<li>将起点 v 和 w 加入 Queue 中，v 和 w 与遍历起点的距离 distanceToStart 为0；</li>
<li>从 Queue 中取出一个节点 s ，如果其父节点（<code>Digraph.adj()</code>）未被遍历，将其加入队列，对应的与遍历起点的距离为 distanceToStart(s) + 1，标记为已遍历；</li>
<li>测试起点 v, w 是否都有路径到达 s，如果有，则 s 为 common ancestor，记录该节点，并将该节点到 v， w 的距离之和( <code>distance(v -&gt; s) + distance(w -&gt; s)</code> )设置为当前找到的 SAP 路径长度；</li>
<li>重复步骤 2-4 直到 Queue 为空。</li>
</ol>
<p>该方法与 Breadth First Search 的思想相似。但仍可以继续优化，设置提前结束条件。在 Queue 中读出的节点与遍历起点的距离是递增的，而且 s 到 起点 v， w 的距离之和一定不小于 s 与遍历起点的距离（v， w 中的一个就是遍历起点，到另一个的距离一定 &gt;= 0）。当 s 与遍历起点的距离大于当前找到的最短路径长度时，则可以提前结束遍历，因为之后找到的所有顶点到 v， w 的距离之和一定更大。</p>
<p>该方法只会遍历有限的节点，当找到的 SAP 路径长度足够小时会提前结束遍历，能够快速找出 SAP。</p>
<h1 id="自定义_BreadthFirstSearchPath">自定义 BreadthFirstSearchPath</h1><p>如果分析上节<code>从起点遍历</code>中的方法会发现，执行效率进一步提高的瓶颈来自于类 <code>BreadthFirstSearchPath</code> 的初始化。</p>
<p>使用方法 <code>disTo(s)</code> 得到 <code>distance(v -&gt; s)</code> 之前需要向 <code>BreadthFirstSearchPath</code> 传入 <code>Digraph</code> 与路径起点 <code>v</code> 进行初始化。 在该类的实现中，初始化过程会使用 Breadth First Search 遍历起点 <code>v</code> 的所有 ancestor 节点并记录到起点的距离，之后在调用方法 <code>disTo(s)</code> 时直接返回保存的距离值。</p>
<p>换言之，在寻找 v 与 w 的 SAP 之前，要预先计算 v 与 w 的所有 ancestor 节点的距离，再根据得到的距离寻找 SAP。但是不是每次寻找都会用到所有的 ancestor 节点，特别是 SAP 节点距离起点较近时，大部分 ancestor 节点的距离计算是“毫无意义”的。因此，为了进一步提高算法效率，可以实现自己的 BreadthFirstSearchPath 方法，将距离的计算与 common ancestor 的寻找结合到一次 Breadth First Search 中，在找到所需 SAP 时停止寻找。基本执行步骤与上节中的搜索执行步骤十分相似，只是需要保存的数据不同：</p>
<ol>
<li>将起点 v 和 w 加入 Queue 中同时区分标记节点的来源，v 和 w 与各自遍历起点的距离 distanceToV (或 distanceToW) 为0；</li>
<li>从 Queue 中取出一个节点 s ，如果 s 到其来源起点的距离大于当前已知的 SAP 路径长度，停止遍历；
3.如果 s 的父节点（<code>Digraph.adj()</code>）未被 s 的来源方向遍历，将其加入队列，其与来源遍历起点的距离为 distanceToV(s) + 1（或 distanceToW(s) + 1），同时标记为已从来源方向遍历；</li>
<li>测试 s 是否已被 v， w 两个方向遍历，如果是，则 s 为 common ancestor，记录该节点，并将该节点到 v， w 的距离之和( <code>distanceToV(s) + distanceTow(s)</code> )设置为当前找到的最短路径长度；</li>
<li>重复步骤 2-5 直到 Queue 为空。</li>
</ol>
<h2 id="顶点集输入">顶点集输入</h2><p>前文讨论了单顶点输入下的算法，对于顶点集（多顶点）输入的情况处理与单顶点相同，只是将每个方向的起点由一个增加为多个，由于 Breadth First Search 的特性，在遍历过程中找到的顶点与起点的距离一定是与所有的来源方向起点距离中最小的一个。最后得到的结果也会符合 节点集 v 中任一节点与节点集 w 中任一节点的所有 SAP 中长度最小的一个的要求。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在有向图（Digraph）中，由一个节点（Vertex）沿着边（Edge）可以到达的节点称为其 ancestor（祖先）。当两个不同节点拥有一个共同 ancestor 时，该 ancestor 称这两个节点的 Common Ancestor （共同祖先），Shortest Ancestral Path （SAP，最短祖先路径）即所有 common ancestor 中到两个节点路径之和最短的一个及其对应的路径。</p>]]>
    
    </summary>
    
      <category term="Algorithms" scheme="https://libhappy.com/tags/Algorithms/"/>
    
      <category term="Princeton" scheme="https://libhappy.com/tags/Princeton/"/>
    
      <category term="algs" scheme="https://libhappy.com/tags/algs/"/>
    
      <category term="union-find" scheme="https://libhappy.com/tags/union-find/"/>
    
      <category term="并查集" scheme="https://libhappy.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="算法" scheme="https://libhappy.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithms" scheme="https://libhappy.com/categories/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[普林斯顿算法（1.4）quick-union算法的优化]]></title>
    <link href="https://libhappy.com/2016/03/algs-1.4/"/>
    <id>https://libhappy.com/2016/03/algs-1.4/</id>
    <published>2016-03-13T05:14:36.000Z</published>
    <updated>2016-03-16T11:36:38.000Z</updated>
    <content type="html"><![CDATA[<p>在动态连通性问题中，quick-union算法改进了quick-find算法中union()方法的执行速度，但是并不能在所有输入情况下都提升执行速度。以下来介绍对于quick-union算法的一些优化。</p>
<a id="more"></a>
<!--toc-->
<h1 id="加权quick-union算法">加权quick-union算法</h1><p>在quick-union算法中，使用了树这种数据结构来组织数据，但是在某些输入情况下，树的高度会变得太高，导致从某些触点链接到根触点的中间过程（find()方法执行过程）太多。查看quick-union算法的实现，树高度的增长来自于union()方法中合并两个分量的过程，即以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id[pRoot] = qRoot;</span><br></pre></td></tr></table></figure>
<p>可以看到这行代码直接将p触点所在的分量链接到了q触点所在分量的根触点上，并没有进行任何的比较判断（可以说这个链接的过程中选择链接方向是随意的）。这样当每次的输入都是p触点所在分量（树）较高时，会导致树的高度快速增加。那么解决方案就较为简单了，在链接两个分量之前，对两个分量进行比较，保证将较小的树链接到较大的树上。这样，树会倾向于横向的长大，而不是长高。</p>
<div class="figure center nocaption"><a class="fancybox" href="https://farm2.staticflickr.com/1683/25736804541_8bed7e414e_z.jpg" title="加权quick-union算法示意" target="_blank" rel="external"><img class="fig-img" src="https://farm2.staticflickr.com/1683/25736804541_8bed7e414e_z.jpg" alt="加权quick-union算法示意"></a></div>
<p>为了随时获得每个分量所在树的大小，需要添加一个数组（sz）来记录每个分量树中触点的个数。初始化时，每个触点都是独立的一个分量，每个分量的大小都是1，当合并两个分量时，首先获得分量根触点及根触点所代表的分量大小，比较之后将较小的分量链接到较大的分量，最后更新合成后分量（较大分量）根触点所代表的分量大小。</p>
<h2 id="实现">实现</h2><figure class="highlight java"><figcaption><span>加权quick-union算法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightedQuickUnionUF</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sz;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeightedQuickUnionUF</span><span class="params">(<span class="keyword">int</span> N)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        count = N;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        sz = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">            sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123; <span class="keyword">return</span> find(p) == find(q); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (p != id[p]) p = id[p];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span> (pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (sz[pRoot] &gt; sz[qRoot]) &#123; id[qRoot] = pRoot; sz[pRoot] += sz(qRoot); &#125;</span><br><span class="line">        <span class="keyword">else</span>                       &#123; id[pRoot] = qRoot; sz[qRoot] += sz(pRoot); &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法分析">算法分析</h2><div class="figure center nocaption"><a class="fancybox" href="https://farm2.staticflickr.com/1643/25805847416_4f078530bf_c.jpg" title="quick-union与加权quick-union算法对比" target="_blank" rel="external"><img class="fig-img" src="https://farm2.staticflickr.com/1643/25805847416_4f078530bf_c.jpg" alt="quick-union与加权quick-union算法对比"></a></div>
<p>通过两种算法对比图可以看出，加权quick-union算法最后得到的树要“扁平”的多，树的高度大幅减小，在执行find()方法时也更有效率。<strong>加权quick-union算法构造的森林中的任意节点的深度最多为lgN</strong>，比quick-union算法中的最大深度N要小得多。在处理有N个触点M条连接时加权quick-union算法最多访问数组cMlgN次，其中c为常数；而quick-find算法需要访问数组MN次。加权quick-union算法能够保证在合理的时间范围内解决实际中的大规模动态连通性问题。</p>
<h1 id="最优算法">最优算法</h1><p>通过上面加权quick-union算法的分析，很容易发现，对于最优化的quick-union算法而言，得到的应该是一颗十分扁平的树，最为极端的情况就是在分量中所有的触点都直接链接到根触点上，即进行<strong>路径压缩</strong>。实现路径压缩很简单，在加权quick-union算法的find*()方法中，将在寻找根触点过程中遇到的所有触点都直接链接到根触点上。</p>
<h2 id="实现-1">实现</h2><figure class="highlight java"><figcaption><span>路径压缩的加权quick-union算法(仅find()方法)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> orgp = p;</span><br><span class="line">        <span class="keyword">while</span>(p != id[p]) p = id[p];</span><br><span class="line">        <span class="comment">//将从orgp到根节点上的每个触点都连接到根节点</span></span><br><span class="line">        <span class="keyword">while</span>(orgp != id[orgp])</span><br><span class="line">        &#123;</span><br><span class="line">            orgp = id[orgp];</span><br><span class="line">            id[orgp] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法分析-1">算法分析</h2><p>路径压缩的加权quick-union算法得到的是几乎完全扁平的树。但是从代码中很容易发现，在find()方法中找到根触点后要对遇到的所有触点再次进行读取操作，虽然路径被压缩了，但是对数组的读取并不能完全降至1次。因此虽然<strong>路径压缩的加权quick-union算法是最优的算法</strong>，但并非所有操作都能在常数时间内完成。</p>
<p>除了这种极端的路径压缩方法，也有实现更为简单但是压缩效率不那么高的路径压缩方法，比如：将遇到的触点的父节点指向该触点的父触点的父触点（爷爷触点），相当于在寻找根触点的同时，对路径进行了压缩。其实现十分简单，只需要在find()方法中添加一行代码。当然在一些输入情况下，树的深度会远超过2，所以这种简单的路径压缩方法并没有上面所说的算法高效。
<figure class="highlight java"><figcaption><span>简单路径压缩的加权quick-union算法(仅find()方法)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(p != id[p])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将p节点链接到其的爷爷触点</span></span><br><span class="line">            id[p] = id[id[p]];</span><br><span class="line">            p = id[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">总结</h1><p>在union-find算法中<strong>路径压缩的加权quick-union算法是最优的算法</strong>，但并非所有操作都能在常数时间内完成。且不存在其他算法能够保证union-find算法的所有操作在均摊后都是常数级别的。</p>
<p>各种union-find算法的性能特点如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">算法</th>
<th style="text-align:center">构造函数*</th>
<th style="text-align:center">union()*</th>
<th style="text-align:center">find()*</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">quick-find算法</td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:left">quick-union算法</td>
<td style="text-align:center">N</td>
<td style="text-align:center">树高度</td>
<td style="text-align:center">树高度</td>
</tr>
<tr>
<td style="text-align:left">加权quick-union算法</td>
<td style="text-align:center">N</td>
<td style="text-align:center">lgN</td>
<td style="text-align:center">lgN</td>
</tr>
<tr>
<td style="text-align:left">路径压缩的加权quick-union算法</td>
<td style="text-align:center">N</td>
<td style="text-align:center">接近1但未达到1（均摊成本）</td>
<td style="text-align:center">接近1但未达到1（均摊成本）</td>
</tr>
<tr>
<td style="text-align:left">理想情况</td>
<td style="text-align:center">N</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>*存在N个触点时成本的增长数量级（最坏情况下）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在动态连通性问题中，quick-union算法改进了quick-find算法中union()方法的执行速度，但是并不能在所有输入情况下都提升执行速度。以下来介绍对于quick-union算法的一些优化。</p>]]>
    
    </summary>
    
      <category term="Algorithms" scheme="https://libhappy.com/tags/Algorithms/"/>
    
      <category term="Princeton" scheme="https://libhappy.com/tags/Princeton/"/>
    
      <category term="algs" scheme="https://libhappy.com/tags/algs/"/>
    
      <category term="union-find" scheme="https://libhappy.com/tags/union-find/"/>
    
      <category term="并查集" scheme="https://libhappy.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="算法" scheme="https://libhappy.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithms" scheme="https://libhappy.com/categories/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[普林斯顿算法（1.3）并查集（union-find算法）]]></title>
    <link href="https://libhappy.com/2016/03/algs-1.3/"/>
    <id>https://libhappy.com/2016/03/algs-1.3/</id>
    <published>2016-03-12T04:15:03.000Z</published>
    <updated>2016-03-16T09:20:50.000Z</updated>
    <content type="html"><![CDATA[<p>假设在互联网中有两台计算机需要互相通信，那么该怎么确定它们之间是否已经连接起来还是需要架设新的线路连接这两台计算机。这就是动态连通性问题。动态连通性问题在日常生活中十分常见，比如上文所说的通信网络中的连通性问题，比如物理化学中的渗流问题。通过并查集这种数据结构及union-find算法可以解决动态连通性问题。</p>
<a id="more"></a>
<!--toc-->
<h1 id="动态连通性问题">动态连通性问题</h1><h2 id="概念">概念</h2><p>给出一系列的对象时，让其支持以下的两个操作：</p>
<ul>
<li>判断两个对象是否相连</li>
<li>使两个对象相连</li>
</ul>
<p>这里以整数代表对象，有0-9共十个整数，当给出一个整数对（a, b）时表示将整数a和b相连（如果a、b不相连）。如下图所示：
<div class="figure center nocaption"><a class="fancybox" href="https://farm2.staticflickr.com/1532/25760901136_9e84ce6bf4.jpg" title="动态连通性问题" target="_blank" rel="external"><img class="fig-img" src="https://farm2.staticflickr.com/1532/25760901136_9e84ce6bf4.jpg" alt="动态连通性问题"></a></div></p>
<p>随着整数对的输入，十个整数的连通性会发生变化，这就是<strong>动态连通性问题</strong>。</p>
<p>在动态连通性问题中，我们假设“相连”是一种等价关系，也就意味着它具有：</p>
<ul>
<li>自反性：p和p是相连的</li>
<li>对称性：如果p和q是相连的，那么q和p也是相连的</li>
<li>传递性：如果p和q是相连的且q和r是相连的，那么p和r是相连的。</li>
</ul>
<p>在所有给出的对象中，所有相连的一组对象称为<strong>连通分量（Connected component）</strong>。如上图中最后一行的（0, 1, 2, 5, 6, 7）和（3, 4, 8, 9）分别为两个连通分量。</p>
<h2 id="应用">应用</h2><ul>
<li>计算机网络：判断网络中的计算机是否可以通过已存在的连接直接通信；</li>
<li>社交网络中的朋友关系：将朋友关系当作相连，判断两个人之间的朋友关系；</li>
<li>计算机芯片中晶体管的连接问题：判断芯片中晶体管是否相连；</li>
<li>变量名的等价性：某些编程语言（如FORTRAN）中允许声明两个等价的变量名，判断两个给定的变量名是否等价；</li>
<li>数学集合中的元素：元素可能属于不同的集合，将元素“相连”表示将两个元素所属的集合合并成一个集合。</li>
</ul>
<p>如在下图所示的所有连接中判断p和q点之间是否相连。
<div class="figure center nocaption"><a class="fancybox" href="https://farm2.staticflickr.com/1593/25176100634_abf63e651b.jpg" title="动态连通性问题示例-寻找两点之间的连接" target="_blank" rel="external"><img class="fig-img" src="https://farm2.staticflickr.com/1593/25176100634_abf63e651b.jpg" alt="动态连通性问题示例-寻找两点之间的连接"></a></div></p>
<h1 id="设计算法">设计算法</h1><p>在为动态连通性问题设计算法之前要精确的定义问题，动态连通性问题只要求给出两个点是否相连，并不要求给出具体的连接路径，至于得到连接路径的问题，可以通过<em>深度优先搜索（DFS）</em>算法来解决。</p>
<p>在该算法中，要实现以下操作：</p>
<ul>
<li>Find：给出的对象p属于哪个分量；</li>
<li>Connected：对象p和q是否相连；</li>
<li>Union：连接对象p和q并将它们所属的分量合并为一个分量。</li>
</ul>
<p>那么判断两个对象是否相连的最直观简单的方法就是判断它们所属的分量是否相同。所对应的union-find算法API如下：</p>
<table>
<thead>
<tr>
<th style="text-align:right">public class UF</th>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right"></td>
<td style="text-align:left">UF(int N)</td>
<td style="text-align:left">以整数标识(0到N-1)初始化N个触点</td>
</tr>
<tr>
<td style="text-align:right">void</td>
<td style="text-align:left">union(int p, int q)</td>
<td style="text-align:left">在p和q之间添加一条连接</td>
</tr>
<tr>
<td style="text-align:right">int</td>
<td style="text-align:left">find(int p)</td>
<td style="text-align:left">返回p所在分量的标识符</td>
</tr>
<tr>
<td style="text-align:right">boolean</td>
<td style="text-align:left">connected(int p , int q)</td>
<td style="text-align:left">判断p和q是否相连</td>
</tr>
<tr>
<td style="text-align:right">int</td>
<td style="text-align:left">count()</td>
<td style="text-align:left">所有连通分量的数量</td>
</tr>
</tbody>
</table>
<p>在这份API中，用整数表示一个对象（借用网络中的术语，将对象称为<em>触点</em>），那么N个触点就用0到N-1的整数标识。用一个以触点为索引的数组作为基本的数据结构来表示所有的分量，使用分量中的某个触点的名称作为分量的标识符。初始化时触点之间都不相连，因此有N个分量，每个触点构成一个只含有自己的分量。一份初始的代码实现如下：</p>
<figure class="highlight java"><figcaption><span>union-find的实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] id;      <span class="comment">//分量id（以触点作为索引）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;     <span class="comment">//分量的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> N)</span></span><br><span class="line">    </span>&#123; <span class="comment">//初始化分量id数组</span></span><br><span class="line">        count = N;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span><br><span class="line">    </span>&#123; <span class="keyword">return</span> find(p) == find(q); &#125;</span><br><span class="line">    <span class="comment">// find 及 union方法在之后实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面将分别介绍不同的find()和union()方法的实现。</p>
<h1 id="快速查找">快速查找</h1><p>既然用分量标识符代表一个分量，那么直接使同一分量中的所有触点的分量标识符相同即可，在判断两个触点的连通情况时只需比较其对应的分量标识符是否相同，即 id[p] == id[q]。那么在实现union()方法时，首先判断p和q是否同属一个分量，如果不是，则需要合并两者所代表的分量。根据同一分量中所有触点的分量标识符相同的原则，遍历整个数组，将所有与id[p]相等的元素值变为id[q]。这样的实现称为<strong>quick-find（快速查找）算法</strong>。</p>
<h2 id="实现">实现</h2><figure class="highlight java"><figcaption><span>quick-find算法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> id[p]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 判断p和q是否相连，connected操作</span></span><br><span class="line">    <span class="keyword">int</span> pID = id[p];</span><br><span class="line">    <span class="keyword">int</span> qID = id[q];</span><br><span class="line">    <span class="keyword">if</span> (pID != qID)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id.length; i++)</span><br><span class="line">            <span class="keyword">if</span> (id[i] == pID) id[i] = qID;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法分析">算法分析</h2><p>在quick-find算法中，find()操作的速度很快，但是在union()操作中，每一对处于不同分量的输入都需要遍历整个id[]数组。每个方法执行中访问数组的次数如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:left">内部调用</th>
<th style="text-align:center">访问数组次数</th>
<th style="text-align:center">合计</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">find()</td>
<td style="text-align:left"></td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">union()*</td>
<td style="text-align:left">判断是否相连</td>
<td style="text-align:center">2</td>
<td style="text-align:center">N+3 ~ 2N+1</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">检查所有元素</td>
<td style="text-align:center">N</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">改变元素</td>
<td style="text-align:center">1 ~ N-1</td>
</tr>
</tbody>
</table>
<p>*假设两个分量需合并</p>
<p>那么假设使用quick-find算法来解决动态连通性问题并且最后只得到一个连通分量时，至少需要调用N-1次union()方法，即至少要<code>(N+3)(N-1) ~ N^2</code>次访问数组。quick-find算法的复杂度是平方级别的，当数组较大时，运行的效率就较低了。</p>
<h1 id="快速合并">快速合并</h1><p>在quick-find算法中，find()操作速度很快，而union()操作当需要合并分量时要遍历整个数组因而效率较低。在合并分量时，需要关注的并不是所有的触点，只是与元素p同属一个分量的触点才需要被访问，因此，将同一分量中的触点组织结合起来，当需要修改时直接访问该分量中的触点可以减少无关触点的访问。</p>
<p>同样是以触点为索引的id[]数组，但其中保存的值不再是相同的分量标识符，而是同一分量中另一个触点（可能为自己）的名称。当实现find()方法时，从给定的触点开始，再由这个触点链接到第三个触点，直到<strong>根触点</strong>——链接指向自己的触点，那么这个根触点就代表了这个分量。当判断两个触点是否相连时，沿着各自的链接得到根触点后比较根触点是否相同即可。</p>
<p>在实现union()方法时，为了保证合并后的两个分量中的所有触点的根触点相同，直接将其中一个分量的根触点链接到另一个分量的根触点上就可以快速的合并两个分量。因此这个算法叫做quick-union（快速合并）算法。</p>
<div class="figure center nocaption"><a class="fancybox" href="https://farm2.staticflickr.com/1664/25780508646_20a98f07fd_b.jpg" title="quick-union算法示意图" target="_blank" rel="external"><img class="fig-img" src="https://farm2.staticflickr.com/1664/25780508646_20a98f07fd_b.jpg" alt="quick-union算法示意图"></a></div>
<p>从上图的quick-union算法示意图可以看出，quick-union算法中采用了树结构来取代quick-find中使用的数组来组织元素，实现高效的元素查找与修改。</p>
<h2 id="实现-1">实现</h2><figure class="highlight java"><figcaption><span>quick-union算法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p != id[p]) p = id[p];</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">    <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">    <span class="keyword">if</span> (pRoot != qRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        id[pRoot] = qRoot;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法分析-1">算法分析</h2><p>quick-union算法看起来比quick-union算法更快，因为它不需要在每次合并分量时遍历整个数组。但是quick-union算法的性能依赖输入的特点。在最好的情况下，find()方法只需要访问数组一次就可以得到根触点，此时的算法复杂度是线性级别的。但是想象一下这种情况：输入的整数对是完全有序的0-1，0-2，0-3等，N-1对之后N个触点将全部处相同的分量之中（如下图所示）。此时find()操作仍然需要2N+1次数组访问，此时的算法复杂度为平方级别。</p>
<div class="figure center nocaption"><a class="fancybox" href="https://farm2.staticflickr.com/1642/25711574351_abe5a691b8.jpg" title="quick-union算法最坏情况示意图" target="_blank" rel="external"><img class="fig-img" src="https://farm2.staticflickr.com/1642/25711574351_abe5a691b8.jpg" alt="quick-union算法最坏情况示意图"></a></div>
<p>因此，quick-union算法可以看做是对quick-find算法的一种改良，它解决了quick-find算法中union()操作总是线性级别的问题。但quick-union算法仍然存在问题，它不是在所有输入情况下都比quick-find算法快。在下一篇文章中将介绍对quick-union算法的优化，以达到更好的性能。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>假设在互联网中有两台计算机需要互相通信，那么该怎么确定它们之间是否已经连接起来还是需要架设新的线路连接这两台计算机。这就是动态连通性问题。动态连通性问题在日常生活中十分常见，比如上文所说的通信网络中的连通性问题，比如物理化学中的渗流问题。通过并查集这种数据结构及union-find算法可以解决动态连通性问题。</p>]]>
    
    </summary>
    
      <category term="Algorithms" scheme="https://libhappy.com/tags/Algorithms/"/>
    
      <category term="Princeton" scheme="https://libhappy.com/tags/Princeton/"/>
    
      <category term="algs" scheme="https://libhappy.com/tags/algs/"/>
    
      <category term="union-find" scheme="https://libhappy.com/tags/union-find/"/>
    
      <category term="并查集" scheme="https://libhappy.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="算法" scheme="https://libhappy.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithms" scheme="https://libhappy.com/categories/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[普林斯顿算法（1.2）算法分析]]></title>
    <link href="https://libhappy.com/2016/03/algs-1.2/"/>
    <id>https://libhappy.com/2016/03/algs-1.2/</id>
    <published>2016-03-11T05:01:25.000Z</published>
    <updated>2016-03-12T14:04:59.000Z</updated>
    <content type="html"><![CDATA[<p>随着计算机处理数据量的增大，程序运行时消耗的时间与内存空间也逐步增加。对于同一个问题，不同的算法解决方案所耗费的代价不尽相同，对算法的性能进行合理、准确的分析可以为算法的选择、改进提供可靠的依据。
<a id="more"></a>
<!--toc--></p>
<h1 id="算法分析方法">算法分析方法</h1><p>算法分析的基础是科学的研究方法，即：<em>使用<strong>数学分析</strong>为算法成本建立简洁的模型并使用<strong>实验数据</strong>验证这些模型</em>。其基本步骤如下：</p>
<ul>
<li>细致的观察真实世界的特点，通常还要有精确的测量；</li>
<li>根据观察结果提出加收模型；</li>
<li>根据模型预测未来的事件；</li>
<li>继续观察并核实预测的准确性；</li>
<li>如此反复直到确认预测和观察一致。</li>
</ul>
<p>科学的研究方法有两个重要原则：</p>
<ol>
<li>所设计的实验必须是<strong>可重现</strong>的；</li>
<li>所有的假设也必须是<strong>可证伪</strong>的。</li>
</ol>
<h1 id="数学模型">数学模型</h1><p>一个程序的运行总时间主要和两点有关：</p>
<ul>
<li>执行每条语句的耗时</li>
<li>执行每条语句的次数</li>
</ul>
<p>其中前者取决于计算机、程序编译器及操作系统等因素；后者取决于程序本身及输入的数据。</p>
<h2 id="基本操作耗时">基本操作耗时</h2><p>下表为Java中一些基本操作耗时</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">举例</th>
<th style="text-align:center">耗时（纳秒）*</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">整数加法</td>
<td style="text-align:center">a + b</td>
<td style="text-align:center">2.1</td>
</tr>
<tr>
<td style="text-align:center">整数乘法</td>
<td style="text-align:center">a * b</td>
<td style="text-align:center">2.4</td>
</tr>
<tr>
<td style="text-align:center">整数除法</td>
<td style="text-align:center">a / b</td>
<td style="text-align:center">5.4</td>
</tr>
<tr>
<td style="text-align:center">浮点数加法</td>
<td style="text-align:center">a + b</td>
<td style="text-align:center">4.6</td>
</tr>
<tr>
<td style="text-align:center">浮点数乘法</td>
<td style="text-align:center">a * b</td>
<td style="text-align:center">4.2</td>
</tr>
<tr>
<td style="text-align:center">浮点数除法</td>
<td style="text-align:center">a / b</td>
<td style="text-align:center">13.5</td>
</tr>
<tr>
<td style="text-align:center">正弦</td>
<td style="text-align:center">Math.sin(theta)</td>
<td style="text-align:center">91.3</td>
</tr>
<tr>
<td style="text-align:center">反正切</td>
<td style="text-align:center">Math.atan2(y, x)</td>
<td style="text-align:center">129.0</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
<p>*不同编译器、计算机及操作系统结果可能有差异</p>
<p>可以看出，不同的基本操作一般耗时不同。一般在进行算法分析时会假定每个不同指令所需的执行时间是固定不变的。需要注意的是，在指令执行中，非基本操作（Non-primitive operation）的耗时一般要比基本操作耗时多。</p>
<h2 id="执行次数统计">执行次数统计</h2><p>对于以下代码片段，当输入大小为N时，其每个操作的执行次数是多少：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] == <span class="number">0</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">次数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">变量定义</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">赋值操作</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">小于比较</td>
<td style="text-align:center">N + 1</td>
</tr>
<tr>
<td style="text-align:center">等于比较</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">数组访问</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">自增操作</td>
<td style="text-align:center">N ~ 2N</td>
</tr>
</tbody>
</table>
<p>观察上述代码片段可以发现，执行最频繁的指令决定了程序执行的总时间，具体来说就是for循环内的if语句块。一般将这些指令称为程序的<em>内循环</em>。</p>
<h2 id="近似">近似</h2><p>根据程序运算时间的计算方法，假设以上代码块中各项操作的耗时如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">耗时</th>
<th style="text-align:center">次数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">变量定义</td>
<td style="text-align:center">a</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">赋值操作</td>
<td style="text-align:center">b</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">小于比较</td>
<td style="text-align:center">c</td>
<td style="text-align:center">N + 1</td>
</tr>
<tr>
<td style="text-align:center">等于比较</td>
<td style="text-align:center">d</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">数组访问</td>
<td style="text-align:center">e</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">自增操作</td>
<td style="text-align:center">f</td>
<td style="text-align:center">N + x *</td>
</tr>
</tbody>
</table>
<p>*假设输入的N个数据中有x个为0。</p>
<p>则操作的总耗时为：
(c + d + e + f)N + (2a + 2b + c + xf)</p>
<p>这样的表达较为复杂冗长。一般在这种表达式中，首相（幂数最高项）之后的项之和相对较小。那么操作的总耗时可以近似表达为：
~ (c + d + e + f)N</p>
<p>由于我们假设每个操作的耗时是固定不变的，那么在分析比较算法时可以省略这些相同的参数，简化为：
~ N</p>
<p>同时更应该关注的是耗时随输入增长的数量级。对于上述例子来说就是<code>N</code>即，该代码片段的运行耗时随输入的增长是<strong>线性级别</strong>的。</p>
<h2 id="一般方法">一般方法</h2><p>对于大多数程序，得到其运行时间的数学模型所需的步骤如下：</p>
<ul>
<li>确定输入模型，定义问题的规模</li>
<li>识别内循环</li>
<li>根据内循环中的操作确定成本模型</li>
<li>对于给定的输入，判断这些操作的执行频率</li>
</ul>
<p>如果一个程序含有多个方法，分别讨论它们。</p>
<h1 id="增长数量级的分类">增长数量级的分类</h1><p>算法运行成本增长的数量级一般都是问题规模N的若干函数之一，下表给出了常见的增长数量级：</p>
<table>
<thead>
<tr>
<th style="text-align:center">描述</th>
<th style="text-align:center">增长数量级</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">常数级别</td>
<td style="text-align:center">1</td>
<td style="text-align:center">普通语句</td>
<td style="text-align:center">将两个数相加</td>
</tr>
<tr>
<td style="text-align:center">对数级别</td>
<td style="text-align:center">logN</td>
<td style="text-align:center">二分策略</td>
<td style="text-align:center">二分查找</td>
</tr>
<tr>
<td style="text-align:center">线性级别</td>
<td style="text-align:center">N</td>
<td style="text-align:center">循环</td>
<td style="text-align:center">找出最大数</td>
</tr>
<tr>
<td style="text-align:center">线性对数级别</td>
<td style="text-align:center">NlogN</td>
<td style="text-align:center">分治</td>
<td style="text-align:center">归并排序</td>
</tr>
<tr>
<td style="text-align:center">平方级别</td>
<td style="text-align:center">N^2</td>
<td style="text-align:center">双层循环</td>
<td style="text-align:center">检查所有元素对</td>
</tr>
<tr>
<td style="text-align:center">立方级别</td>
<td style="text-align:center">N^3</td>
<td style="text-align:center">三层循环</td>
<td style="text-align:center">检查所有三元组</td>
</tr>
<tr>
<td style="text-align:center">指数级别</td>
<td style="text-align:center">2^N</td>
<td style="text-align:center">穷举查找</td>
<td style="text-align:center">检查所有子集</td>
</tr>
</tbody>
</table>
<h1 id="算法分析">算法分析</h1><h2 id="算法分析的分类">算法分析的分类</h2><p>算法的性能分析中，随着输入的不同可能的性能表现也不同。</p>
<p>以二分查找为例：输入的数组顺序会影响查找的效率，在最好的情况下，第一次查找就可以找到所需的元素，此时的算法性能为<code>~1</code>即常数级别，但是在最坏的情况下，还是需要<code>~lgN</code>次查找才能找到所需元素。</p>
<p>对应的有三种不同情况下的算法性能：</p>
<ul>
<li>最好情况：算法开销的下限<ul>
<li>“最有利”的输入</li>
<li>为所有的输入提供了一个最小开销的目标</li>
</ul>
</li>
<li>最差情况：算法性能的上限<ul>
<li>“最不利”的输入</li>
<li>为所有输入提供了一个最大开销的保证</li>
</ul>
</li>
<li>平均情况：随机输入下的期望开销<ul>
<li>需要“随机的输入”</li>
<li>提供了算法的预期表现</li>
</ul>
</li>
</ul>
<h2 id="上下限">上下限</h2><p>算法分析可以确定问题的“复杂程度”，同时为开发“最理想”的算法提供依据。在算法分析中，通过分析不变因素下的算法性能可以减少算法分析的细节；同时，关注最差情况下的算法性能可以消除输入数据的差异对算法性能的影响。</p>
<p>通过算法分析能够获得算法复杂度的上限与下限：</p>
<ul>
<li>理论上限：算法性能的最低保证，实际使用中算法的复杂度不高于理论上限。</li>
<li>理论下限：算法性能的最好情况，实际使用中算法复杂度不可能低于其理论下限。</li>
</ul>
<p>当一个算法的理论上限与理论下限相同时，称其为最佳算法（Optimal algorithm），该算法的性能不受输入情况的影响，在任何情况下都能保证运行时间在理论范围内。</p>
<h2 id="算法分析中常用符号">算法分析中常用符号</h2><p>下表列出了算法分析中常用的表示算法复杂度的符号及其意义：</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:left">代表意义</th>
<th style="text-align:center">示例</th>
<th style="text-align:left">可表示表达式</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">波浪号</td>
<td style="text-align:left">算法复杂度首相</td>
<td style="text-align:center">~10N^2</td>
<td style="text-align:left">10N^2 + 22NlogN</td>
<td style="text-align:center">近似的数学模型</td>
</tr>
<tr>
<td style="text-align:center">大写Theta</td>
<td style="text-align:left">算法复杂度增长情况</td>
<td style="text-align:center">Θ(N^2)</td>
<td style="text-align:left">5N^2 + 22NlogN</td>
<td style="text-align:center">算法分类</td>
</tr>
<tr>
<td style="text-align:center">大写O</td>
<td style="text-align:left">可能的最大算法复杂度（为Θ(N^2)或更小）</td>
<td style="text-align:center">O(N^2)</td>
<td style="text-align:left">5N^2 + 22NlogN 或 3N</td>
<td style="text-align:center">算法复杂度的理论上限</td>
</tr>
<tr>
<td style="text-align:center">大写Omega</td>
<td style="text-align:left">可能的最小算法复杂度（为Θ(N^2)或更大）</td>
<td style="text-align:center">Ω(N^2)</td>
<td style="text-align:left">5N^2 或 N^3 + 22Nlog N + 3N</td>
<td style="text-align:center">算法复杂度的理论下限</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<p>随着计算机处理数据量的增大，程序运行时消耗的时间与内存空间也逐步增加。对于同一个问题，不同的算法解决方案所耗费的代价不尽相同，对算法的性能进行合理、准确的分析可以为算法的选择、改进提供可靠的依据。]]>
    
    </summary>
    
      <category term="Algorithms" scheme="https://libhappy.com/tags/Algorithms/"/>
    
      <category term="Princeton" scheme="https://libhappy.com/tags/Princeton/"/>
    
      <category term="algs" scheme="https://libhappy.com/tags/algs/"/>
    
      <category term="算法" scheme="https://libhappy.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithms" scheme="https://libhappy.com/categories/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[普林斯顿算法（1.1）链表]]></title>
    <link href="https://libhappy.com/2016/03/algs-1.1/"/>
    <id>https://libhappy.com/2016/03/algs-1.1/</id>
    <published>2016-03-10T08:00:45.000Z</published>
    <updated>2016-03-10T12:38:32.000Z</updated>
    <content type="html"><![CDATA[<p>链表是一种基础的数据结构，在某些情况下链表比数组更适合用来表示集合类的抽象数据类型。链表的定义如下：</p>
<blockquote>
<p>链表是一种递归的数据结构，它或者为空（null），或者是指向一个节点（node）的引用，该节点含有一个泛型的元素和一个指向另一条链表的引用。</p>
</blockquote>
<p>在结构化存储数据集时，<strong>链表是数组的一种重要的替代方式</strong>。</p>
<a id="more"></a>
<!--toc-->
<p>链表的简单图示如下：
<div class="figure center nocaption"><a class="fancybox" href="https://farm2.staticflickr.com/1542/25667290295_892be31c0c_z.jpg" title="链表结构的示例" target="_blank" rel="external"><img class="fig-img" src="https://farm2.staticflickr.com/1542/25667290295_892be31c0c_z.jpg" alt="链表结构的示例"></a></div></p>
<p>一个简单的节点定义如下：
<figure class="highlight crmsh"><figcaption><span>链表中节点的定义</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private class <span class="keyword">Node</span><span class="identifier"></span><br><span class="line"></span><span class="title">&#123;</span><br><span class="line">    Item</span> item;</span><br><span class="line">    <span class="keyword">Node</span><span class="identifier"> </span><span class="title">next</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其中item为某种需要存储的数据，而next代表指向下一个节点的引用。</p>
<p>和数组结构相比，链表更为灵活，可以轻松的向其中插入删除元素而只用更改少量的节点引用，可以任意的增减大小而不用占据多余的内存空间。但是，在获得链表上特定节点的数据时可能会比数组更为耗时。一般情况下外部只会保留对链表中少量节点（一般为第1个节点）的引用，因此为了获得某个节点上的数据需要由一个节点开始不断的遍历下一个节点直到找到所需的节点数据，如果所需的数据在最后一个节点上，那么就需要遍历整个链表。快速的实现获取（插入、删除）任意节点的标准解决方案是使用<strong>双向链表</strong>，即在每个节点上都保存有指向下一个节点及上一个节点的引用。</p>
<h1 id="栈的链表实现">栈的链表实现</h1><p>下压栈的入栈及出栈操作都是在栈的顶部进行的，因此使用链表能够十分方便的实现栈。栈的顶部即为链表的表头，外部引用指向表头节点。当元素入栈时直接在表头添加一个新的节点，并将外部引用指向新的表头；当元素出栈时，取出表头的元素，并修改外部引用为下一个节点。</p>
<p>以下为用链表实现的栈：
<figure class="highlight gradle"><figcaption><span>链表实现的栈</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Stack&lt;Item&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Node first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> Node</span><br><span class="line">    &#123;</span><br><span class="line">        Item item;</span><br><span class="line">        Node <span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isEmpty() &#123; <span class="keyword">return</span> first == <span class="keyword">null</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">size</span>() &#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">push</span>(Item item)</span><br><span class="line">    &#123;</span><br><span class="line">        Node oldFirst = first;</span><br><span class="line">        first = <span class="keyword">new</span> Node();</span><br><span class="line">        first.item = item;</span><br><span class="line">        first.<span class="keyword">next</span> = oldFirst;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="keyword">pop</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        Item item = first.item;</span><br><span class="line">        first = first.<span class="keyword">next</span>;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用链表实现的栈达到了以下目标：</p>
<ul>
<li>可以处理任意的数据类型；</li>
<li>所需的空间总是和集合的大小成正比；</li>
<li>操作所需的时间和集合的大小无关。</li>
</ul>
<h1 id="队列的链表实现">队列的链表实现</h1><p>使用链表来实现队列也十分简单。同时保留指向链表表头及表尾的引用，元素入列时将其添加到表尾，同时修改指向表尾的引用；出列时删除表头的节点，同时修改指向表头的引用。需要注意的是，当链表为空添加一个节点或只有一个节点删除节点时要同时修改指向表头和表尾的引用。</p>
<p>以下为用链表实现的队列：
<figure class="highlight applescript"><figcaption><span>链表实现的队列</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public <span class="type">class</span> Queue&lt;Item&gt;</span><br><span class="line">&#123;</span><br><span class="line">    private Node <span class="keyword">first</span>;</span><br><span class="line">    private Node <span class="keyword">last</span>;</span><br><span class="line">    private int N;</span><br><span class="line">    private <span class="type">class</span> Node</span><br><span class="line">    &#123;</span><br><span class="line">        Item <span class="property">item</span>;</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="type">boolean</span> isEmpty() &#123; <span class="constant">return</span> <span class="keyword">first</span> == null; &#125;</span><br><span class="line">    public int size() &#123; <span class="constant">return</span> N; &#125;</span><br><span class="line">    public void enqueue(Item <span class="property">item</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Node oldLast = <span class="keyword">last</span>;</span><br><span class="line">        <span class="keyword">last</span> = new Node();</span><br><span class="line">        <span class="keyword">last</span>.<span class="property">item</span> = <span class="property">item</span>;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">first</span> = <span class="keyword">last</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            oldLast.next = <span class="keyword">last</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line">    public Item dequeue()</span><br><span class="line">    &#123;</span><br><span class="line">        Item <span class="property">item</span> = <span class="keyword">first</span>.<span class="property">item</span>;</span><br><span class="line">        <span class="keyword">first</span> = <span class="keyword">first</span>.next;</span><br><span class="line">        <span class="keyword">if</span> (size() == <span class="number">1</span>) &#123; <span class="keyword">last</span> = null; &#125;</span><br><span class="line">        N<span class="comment">--;</span></span><br><span class="line"><span class="command">        return</span> <span class="property">item</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="背包的链表实现">背包的链表实现</h1><p>用链表实现背包只需要将栈的实现中push()改名为add()并删除pop()方法。在为背包实现遍历时，由于背包的遍历输出顺序并不重要，也可以直接使用栈的遍历输出。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>链表是一种基础的数据结构，在某些情况下链表比数组更适合用来表示集合类的抽象数据类型。链表的定义如下：</p>
<blockquote>
<p>链表是一种递归的数据结构，它或者为空（null），或者是指向一个节点（node）的引用，该节点含有一个泛型的元素和一个指向另一条链表的引用。</p>
</blockquote>
<p>在结构化存储数据集时，<strong>链表是数组的一种重要的替代方式</strong>。</p>]]>
    
    </summary>
    
      <category term="Algorithms" scheme="https://libhappy.com/tags/Algorithms/"/>
    
      <category term="Princeton" scheme="https://libhappy.com/tags/Princeton/"/>
    
      <category term="algs" scheme="https://libhappy.com/tags/algs/"/>
    
      <category term="算法" scheme="https://libhappy.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithms" scheme="https://libhappy.com/categories/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[普林斯顿算法（1.0）背包、队列和栈]]></title>
    <link href="https://libhappy.com/2016/03/algs-1.0/"/>
    <id>https://libhappy.com/2016/03/algs-1.0/</id>
    <published>2016-03-07T04:59:13.000Z</published>
    <updated>2016-03-16T09:23:01.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p><strong>许多基础数据类型</strong>都和对象的集合有关。具体来说，数据类型的值就是一组对象的集合，所有的操作都是关于添加、删除或是访问集合中的对象。</p>
</blockquote>
<p>本节介绍三种数据类型：背包（Bag）、队列（Queue）和栈（Stack），它们的不同之处在于删除或访问对象的顺序不同。同时还介绍了三种数据类型的数组实现及简单应用，在下一篇中介绍链表及这三种数据类型的链表实现。
<a id="more"></a>
<!--toc--></p>
<h1 id="数据类型简介">数据类型简介</h1><h2 id="背包">背包</h2><p>背包（Bag）是一种不支持从中删除元素的集合数据类型——它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素。迭代遍历的顺序不确定且与用例无关。背包的概念可以借助以下图示理解。
<div class="figure center nocaption"><a class="fancybox" href="https://farm2.staticflickr.com/1698/25643339695_3e775efcaa_z.jpg" title="背包操作示例" target="_blank" rel="external"><img class="fig-img" src="https://farm2.staticflickr.com/1698/25643339695_3e775efcaa_z.jpg" alt="背包操作示例"></a></div></p>
<h2 id="先进先出队列">先进先出队列</h2><p>先进先出队列（Queue，简称队列）是一种基于先进先出（FIFO: First In First Out）策略的集合类型。队列的一个十分常见的例子就是在排队的人。当用例使用遍历访问队列中的元素时，元素的处理顺序就是它们被添加到队列中的顺序。在应用程序中使用队列的主要原因是在用集合保存元素时同时<strong>保存它们的相对顺序</strong>：使它们入列顺序和出列顺序相同。下图是队列的操作示例。
<div class="figure center nocaption"><a class="fancybox" href="https://farm2.staticflickr.com/1609/25643647955_bc5a62c337_z.jpg" title="队列操作示例" target="_blank" rel="external"><img class="fig-img" src="https://farm2.staticflickr.com/1609/25643647955_bc5a62c337_z.jpg" alt="队列操作示例"></a></div></p>
<h2 id="下压栈">下压栈</h2><p>下压栈（Stack，简称栈）是一种基于后进先出（LIFO: Last In First Out）策略的集合类型。在生活中堆成一叠的文件就可以当作一个下压栈，新文件放到最上面，而取出文件阅读时也从最上面开始阅读。这样处理的好处是总能够得到未被处理的文件中最新的一份，坏处是如果不把栈清空，较早的文件可能永远不会被处理。当用例遍历访问栈中的元素时，元素的处理顺序与它们被压入栈中的顺序正好相反。在应用程序中使用栈的一个典型原因是在用集合保存元素的同时<strong>颠倒</strong>它们的相对顺序。下图是栈的操作示例。
<div class="figure center nocaption"><a class="fancybox" href="https://farm2.staticflickr.com/1572/25643648005_52114b7309_z.jpg" title="栈操作示例" target="_blank" rel="external"><img class="fig-img" src="https://farm2.staticflickr.com/1572/25643648005_52114b7309_z.jpg" alt="栈操作示例"></a></div></p>
<h1 id="数组实现">数组实现</h1><h2 id="定容数组">定容数组</h2><p>一种实现Bag，Queue及Stack的简单而经典的方法就是使用数组来保存集合中的数据。Java中的数组在创建时需要指定大小，之后其大小是无法改变的。以下为用定容数组实现的定容字符串栈。
<figure class="highlight java"><figcaption><span>泛型定容字符串栈</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedCapacityStack</span>&lt;<span class="title">Item</span>&gt;</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Item[] a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FixedCapacityStack</span><span class="params">(<span class="keyword">int</span> cap)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">        在Java中创建泛型数组是不允许的，不能使用 a = new Item[cap]。</span><br><span class="line">        因此使用类型转换来创建一个泛型的数组,但编译器会给出警告。</span><br><span class="line">         */</span></span><br><span class="line">        a = (Item[]) <span class="keyword">new</span> Object[cap];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span><br><span class="line">    </span>&#123; <span class="keyword">return</span> N == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span><br><span class="line">    </span>&#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item item)</span></span><br><span class="line">    </span>&#123; a[N++] = item; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span></span><br><span class="line">    </span>&#123; <span class="keyword">return</span> a [--N]; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="调整数组大小">调整数组大小</h2><p>由于Java中数组的大小无法动态改变，因此集合使用的空间只能是这个最大容量的一部分。大容量的用例在集合几乎为空时会浪费大量的内存。另一方面，当集合变得比数组更大时用例可能会<strong>溢出（Overflow）</strong>。如果动态的调整数组的大小就可以避免以上的问题，实现的方法就是将集合在需要时移动到一个大小不同的数组中去。
但是在两个数组中整体的移动集合可能会耗费大量的资源，每次移动集合就需要对集合中的每个元素执行一次读取和写入操作，因此频繁的移动集合是很得不偿失的。同时，如果不经常移动集合，当集合远小于数组大小时，会浪费大量的内存。</p>
<p>一个较好的策略是：
<div class="alert success"><p>当集合大小增加至数组大小时，将集合移动到另一个原数组两倍大的数组中；当集合大小减小至小于数组的四分之一时，将集合移动到另一个原数组一半大的数组中。</p>
</div></p>
<p>以下是一个动态调整数组大小的栈
<figure class="highlight java"><figcaption><span>动态调整大小的栈</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResizingArrayStack</span>&lt;<span class="title">Item</span>&gt;</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Item[] a = (Item[]) <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> N == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> max)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        Item[] temp = (Item[]) <span class="keyword">new</span> Object[max];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            temp[i] = a[i];</span><br><span class="line">        a = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item item)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == a.length) resize(<span class="number">2</span> * a.length);</span><br><span class="line">        a[N++] = item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        Item item = a[--N];</span><br><span class="line">        a[N] = <span class="keyword">null</span>; <span class="comment">//避免对象游离，提示系统垃圾回收不再使用的对象</span></span><br><span class="line">        <span class="keyword">if</span> (N &gt; <span class="number">0</span> &amp;&amp; N == a.length / <span class="number">4</span>) resize(a.length/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="应用">应用</h1><h2 id="算术表达式求值">算术表达式求值</h2><p>栈的一个经典用例是计算算术表达式的值，例如：</p>
<p>( 1 + ( ( 2 + 3 ) * ( 4 + 5 ) ) )</p>
<p>为了简单起见，这里没有省略多余的括号，即只用括号来表示运算的优先级。
E.W.Dijkstra在20世纪60年代发明了一个非常简单的算法来计算算术表达式的值：</p>
<blockquote>
<p>表达式由括号、运算符和操作数（数字）组成。用两个栈（一个保存运算符，一个保存操作数）保存数据，并根据以下4中情况从左至右逐个将这些实体送入栈处理：</p>
<ul>
<li>将操作数压入操作数栈；</li>
<li>将运算符压入运算符栈；</li>
<li>忽略左括号；</li>
<li>在遇到右括号时，弹出一个运算符，弹出所需数量的操作数，并将运算符和操作数的运算结果压入操作数栈。</li>
</ul>
<p>处理完最后一个右括号后，操作数栈上只会有一个值，即表达式的值。</p>
</blockquote>
<p>用图示来解释以上算术表达式的运算过程：
<div class="figure center nocaption"><a class="fancybox" href="https://farm2.staticflickr.com/1641/25643648075_b7e7b776e9_z.jpg" title="双栈算术表达式求值运算过程" target="_blank" rel="external"><img class="fig-img" src="https://farm2.staticflickr.com/1641/25643648075_b7e7b776e9_z.jpg" alt="双栈算术表达式求值运算过程"></a></div></p>
<p>算法示例如下：
<figure class="highlight java"><figcaption><span>Dijkstra 双栈算术表达式求值算法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdIn;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdOut;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Evaluate</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        Stack&lt;String&gt; ops = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">        Stack&lt;Double&gt; vals = <span class="keyword">new</span> Stack&lt;Double&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!StdIn.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            String s = StdIn.readString();</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">"("</span>)) ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">"+"</span>)) ops.push(s);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">"-"</span>)) ops.push(s);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">"*"</span>)) ops.push(s);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">"/"</span>)) ops.push(s);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">"sqrt"</span>)) ops.push(s);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">")"</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                String op = ops.pop();</span><br><span class="line">                <span class="keyword">double</span> v = vals.pop();</span><br><span class="line">                <span class="keyword">if</span> (op.equals(<span class="string">"+"</span>)) v = vals.pop() + v;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(<span class="string">"-"</span>)) v = vals.pop() - v;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(<span class="string">"*"</span>)) v = vals.pop() * v;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(<span class="string">"/"</span>)) v = vals.pop() / v;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(<span class="string">"sqrt"</span>)) v = Math.sqrt(v);</span><br><span class="line">                vals.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> vals.push(Double.parseDouble(s));</span><br><span class="line">        &#125;</span><br><span class="line">        StdOut.println(vals.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p><strong>许多基础数据类型</strong>都和对象的集合有关。具体来说，数据类型的值就是一组对象的集合，所有的操作都是关于添加、删除或是访问集合中的对象。</p>
</blockquote>
<p>本节介绍三种数据类型：背包（Bag）、队列（Queue）和栈（Stack），它们的不同之处在于删除或访问对象的顺序不同。同时还介绍了三种数据类型的数组实现及简单应用，在下一篇中介绍链表及这三种数据类型的链表实现。]]>
    
    </summary>
    
      <category term="Algorithms" scheme="https://libhappy.com/tags/Algorithms/"/>
    
      <category term="Princeton" scheme="https://libhappy.com/tags/Princeton/"/>
    
      <category term="algs" scheme="https://libhappy.com/tags/algs/"/>
    
      <category term="算法" scheme="https://libhappy.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithms" scheme="https://libhappy.com/categories/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[普林斯顿算法（0.0）简介]]></title>
    <link href="https://libhappy.com/2016/03/algs-0.0/"/>
    <id>https://libhappy.com/2016/03/algs-0.0/</id>
    <published>2016-03-07T03:46:52.000Z</published>
    <updated>2016-03-10T04:43:00.000Z</updated>
    <content type="html"><![CDATA[<p>在Coursera上学习了普林斯顿的算法公开课（<a href="https://www.coursera.org/course/algs4partI" target="_blank" rel="external">课程链接</a>， <a href="http://algs4.cs.princeton.edu/home/" target="_blank" rel="external">配套教材网站</a>）。收获很多，对基本的排序，查找算法也有了一些了解，但是时间一久就全忘记了。在接下来的文章中按照课程及配套教材对重要的知识点做一个总结，当作复习与备忘。
<a id="more"></a>
<!--toc--></p>
<h1 id="概要">概要</h1><blockquote>
<p><strong>算法</strong>是指一种有限、确定、有效的并适合用计算机程序来实现的解决问题的方法。</p>
</blockquote>
<p>算法的实现大多数情况下与所使用的编程语言无关，它描述了解决问题的步骤。使用算法的主要原因是它能够节约非常多的资源（时间资源、存储空间资源等），甚至能够让一些本不可能完成的任务变为可能。
在大多数算法中需要适当的组织数据，而为了组织数据数据就产生了<strong>数据结构</strong>。数据结构是存储、组织数据的方式，它和算法的关系十分密切。</p>
<blockquote>
<p>“Algorithms + Data Structures = Programs.” — Niklaus Wirth</p>
</blockquote>
<h1 id="主要内容">主要内容</h1><p>在算法这门课程中将主要讨论以下内容：</p>
<table>
<thead>
<tr>
<th style="text-align:center">主题</th>
<th style="text-align:center">数据结构与算法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">数据类型</td>
<td style="text-align:center">stack, queue, bag, union-find, priority queue</td>
</tr>
<tr>
<td style="text-align:center">排序</td>
<td style="text-align:center">quicksort, mergesort, heapsort, radix sorts</td>
</tr>
<tr>
<td style="text-align:center">查找</td>
<td style="text-align:center">BST, red-black BST, hash table</td>
</tr>
<tr>
<td style="text-align:center">图</td>
<td style="text-align:center">BFS, DFS, Prim, Kruskal, Dijkstra</td>
</tr>
<tr>
<td style="text-align:center">字符串</td>
<td style="text-align:center">KMP, regular expression, tries, data compression</td>
</tr>
<tr>
<td style="text-align:center">高级</td>
<td style="text-align:center">B-tree, k-d tree, suffix array, maxflow</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Coursera上学习了普林斯顿的算法公开课（<a href="https://www.coursera.org/course/algs4partI">课程链接</a>， <a href="http://algs4.cs.princeton.edu/home/">配套教材网站</a>）。收获很多，对基本的排序，查找算法也有了一些了解，但是时间一久就全忘记了。在接下来的文章中按照课程及配套教材对重要的知识点做一个总结，当作复习与备忘。]]>
    
    </summary>
    
      <category term="Algorithms" scheme="https://libhappy.com/tags/Algorithms/"/>
    
      <category term="Princeton" scheme="https://libhappy.com/tags/Princeton/"/>
    
      <category term="algs" scheme="https://libhappy.com/tags/algs/"/>
    
      <category term="算法" scheme="https://libhappy.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithms" scheme="https://libhappy.com/categories/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用Gogs搭建自己的Git服务器]]></title>
    <link href="https://libhappy.com/2016/01/build-gogs-service/"/>
    <id>https://libhappy.com/2016/01/build-gogs-service/</id>
    <published>2016-01-03T09:01:51.000Z</published>
    <updated>2016-03-16T09:40:52.000Z</updated>
    <content type="html"><![CDATA[<p>Git是非常流行的版本管理系统，很多的网站也提供了免费的Git服务，如全球知名的最大源代码托管服务<a href="http://github.com" target="_blank" rel="external">Github</a>。但是大部分的Git源代码托管服务都只对开放的代码托管免费，对私有的代码托管需要收取一定费用。同时，个人的一些代码有时由于各种原因可能并不适合开放，比如：练习用代码，对Git服务提供商的隐私性及安全性有所担忧，包含一些商业机密等等。此时可以搭建自己的Git服务器来托管代码。
<a id="more"></a>
应用最广泛的Git托管程序要数<a href="http://gitlab.com" target="_blank" rel="external">Gitlab</a>，它采用Ruby on Rails，可以实现一个自托管的Git项目仓库，并可以通过网页对公开的或者私人项目进行访问。其功能与Github相似，但搭建过程稍复杂且对系统的配置要求较高。因此我选用了另一个方案Gogs。
<!--toc--></p>
<h1 id="Gogs简介">Gogs简介</h1><p><a href="http://gogs.io" target="_blank" rel="external">Gogs</a>是一款极易搭建的自助Git服务，在官网介绍中它有以下优点：</p>
<ul>
<li>易安装：除了可以根据操作系统平台下载二进制运行，还可以通过Docker或Vagrant，以及包管理安装。</li>
<li>跨平台：任何Go语言支持的平台都可以运行Gogs，包括Windows、Mac、Linux 以及ARM。</li>
<li>轻量级：一个廉价的树莓派的配置足以满足Gogs的最低系统硬件要求。有些用户甚至还将Gogs运行在NAS设备上。</li>
<li>开源化：所有的代码都开源在<a href="https://github.com/gogits/gogs/" target="_blank" rel="external">GitHub</a>。</li>
</ul>
<p>具体的界面可以到官方提供的<a href="https://try.gogs.io/" target="_blank" rel="external">在线体验</a>界面查看。
需要注意的是，Gogs现在还在开发中，在某些具体功能上还不及Gitlab，但相信随着后续的开发功能一定会越来越完备的。</p>
<h1 id="Gogs依赖环境">Gogs依赖环境</h1><p>安装Gogs之前需要配置相应的依赖环境，官网介绍的依赖环境如下：</p>
<ul>
<li>数据库（选择以下一项）：<ul>
<li>MySQL：版本 &gt;= 5.5.3</li>
<li>PostgreSQL</li>
<li>或者 什么都不安装 直接使用 SQLite3 或 TiDB</li>
</ul>
</li>
<li>git（bash）：<ul>
<li>服务端和客户端均需版本 &gt;= 1.7.1</li>
<li>Windows 系统建议使用最新版</li>
</ul>
</li>
<li>SSH 服务器：<ul>
<li>如果您只使用 HTTP/HTTPS 或者内置 SSH 服务器的话请忽略此项</li>
<li>推荐 Windows 系统使用 Cygwin OpenSSH 或 Copssh</li>
</ul>
</li>
<li>Nginx反向代理（可选）</li>
</ul>
<p>以下以Ubuntu服务器为例安装Gogs。</p>
<h1 id="安装Git">安装Git</h1><p>安装Git:
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure></p>
<p>检查Git是否安装成功:
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></p>
<h1 id="安装及配置MySQL数据库">安装及配置MySQL数据库</h1><h2 id="安装MySQL">安装MySQL</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure>
<p>安装时需要配置MySQL的root用户及密码。
检查MySQL是否安装成功
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql --version</span><br></pre></td></tr></table></figure></p>
<h2 id="配置MySQL">配置MySQL</h2><p>创建gogs数据库，配置数据库编码为utf8，数据库引擎为InnoDB。
<figure class="highlight sh"><figcaption><span>mysql</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line">mysql&gt; SET GLOBAL storage_engine = <span class="string">'InnoDB'</span>;</span><br><span class="line">mysql&gt; CREATE DATABASE gogs CHARACTER SET utf8 COLLATE utf8_bin;</span><br><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON gogs.* TO ‘root’@‘localhost’ IDENTIFIED BY ‘password’;</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br><span class="line">mysql&gt; QUIT;</span><br></pre></td></tr></table></figure></p>
<h1 id="新建git用户">新建git用户</h1><p>为运行Gogs创建一个新的用户git：
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser git</span><br></pre></td></tr></table></figure></p>
<p>然后按照提示设置相关用户信息及密码。在后文中运行Gogs时需要以该用户身份运行。</p>
<h1 id="安装Go语言运行环境">安装Go语言运行环境</h1><p>Gogs由Go语言编写，运行时需要安装Golang运行环境。如果系统中其他程序并不需要运行Go语言程序，可以只为上文创建的git用户配置运行环境，也可以选择配置全系统所有用户的Go语言运行环境。</p>
<h2 id="配置环境变量">配置环境变量</h2><p>切换到用户git，并只为该用户配置Go运行环境。
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su git</span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">mkdir go</span><br></pre></td></tr></table></figure></p>
<p>写入环境变量：
<figure class="highlight sh"><figcaption><span>.bashrc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GOROOT=<span class="variable">$HOME</span>/go</span><br><span class="line"><span class="built_in">export</span> GOARCH=<span class="number">386</span>   <span class="comment">#系统位数，386表示32位系统，amd64表示64位系统。</span></span><br><span class="line"><span class="built_in">export</span> GOOS=linux   <span class="comment">#系统类型</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOROOT</span>/bin</span><br></pre></td></tr></table></figure>
使环境变量生效：
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></p>
<h2 id="安装Go">安装Go</h2><p><a href="https://golang.org/dl/" target="_blank" rel="external">Go语言官网</a>可以获取最新的二进制安装包：
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://storage.googleapis.com/golang/go1.<span class="number">5.2</span>.linux-<span class="number">386</span>.tar.gz</span><br><span class="line">tar xzvf go1.<span class="number">5.2</span>.linux-<span class="number">386</span>.tar.gz</span><br><span class="line">mv go <span class="variable">$GOROOT</span></span><br></pre></td></tr></table></figure></p>
<p>Go语言运行环境就安装完成了，测试Golang是否安装成功：
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env</span><br></pre></td></tr></table></figure></p>
<h1 id="安装Gogs">安装Gogs</h1><p>访问<a href="https://gogs.io/docs/installation/install_from_binary" target="_blank" rel="external">Gogs官网</a>可以获取最新的Gogs二进制安装包。
<figure class="highlight sh"><figcaption><span>git@computer:~</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir goapp</span><br><span class="line"><span class="built_in">cd</span> goapp</span><br><span class="line">wget https://storage.googleapis.com/golang/go1.<span class="number">5.2</span>.linux-<span class="number">386</span>.tar.gz</span><br><span class="line">tar xzvf go1.<span class="number">5.2</span>.linux-<span class="number">386</span>.tar.gz</span><br></pre></td></tr></table></figure>
Gogs程序就安装到了<code>~/goapp</code>目录下，可以直接运行gogs。
<figure class="highlight"><figcaption><span>git@computer:~/goapp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd gogs&#10;./gogs web</span><br></pre></td></tr></table></figure>
Gogs默认监听3000端口，此时用浏览器打开服务器IP的3000端口(服务器IP:3000)，在网页中进行初始配置。
需要注意的是，<em>首次运行时建议设置Gogs的管理员账户</em>，拖动到网页最下方填写管理员用户及密码即可。</p>
<h1 id="设置Nginx反向代理">设置Nginx反向代理</h1><p>Gogs默认监听3000端口，使用Nginx将80端口的访问代理至3000端口即可直接通过IP访问Gogs，绑定域名后还可以通过域名访问。</p>
<h2 id="安装Nginx">安装Nginx</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></table></figure>
<h2 id="配置Nginx代理">配置Nginx代理</h2><p>为Gogs创建一个Nginx配置文件：
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/nginx/sites-available/gogs</span><br></pre></td></tr></table></figure></p>
<p>写入以下配置：
<figure class="highlight plain"><figcaption><span>/etc/nginx/sites-available/gogs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server &#123;&#10;    listen 80;&#10;    server_name your_server_ip; # your_server_ip&#20026;&#26381;&#21153;&#22120;IP&#25110;&#32465;&#23450;&#30340;&#22495;&#21517;&#10;&#10;    location / &#123;&#10;        proxy_pass http://127.0.0.1:3000;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
保存后将该配置文件链接到<code>sites-enabled</code>中。
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln <span class="operator">-s</span> /etc/nginx/sites-available/gogs /etc/nginx/sites-enabled/gogs</span><br></pre></td></tr></table></figure></p>
<p>重启nginx：
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service nginx restart</span><br></pre></td></tr></table></figure></p>
<p>然后就可以直接通过域名或IP访问Gogs了。</p>
<h1 id="Gogs运行的其他注意事项">Gogs运行的其他注意事项</h1><p>至此Gogs服务就安装完成了。Gogs运行时还有以下注意事项：</p>
<ol>
<li><p>Gogs的自定义配置文件位于<code>gogs/custom/conf/app.ini</code>，具体的参数配置可以参考官方的<a href="https://gogs.io/docs/advanced/configuration_cheat_sheet.html" target="_blank" rel="external">配置文件手册</a>。比如，如果修改了ssh的默认端口，就需要在自定义配置文件中指定修改后的ssh端口：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SSH_PORT: <span class="number">8888</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>gogs/scripts</code>文件目录中针对不同服务管理软件的已经配置好的Gogs启动脚本文件，比如<code>supervisor</code>脚本的内容如下：</p>
<figure class="highlight plain"><figcaption><span>gogs/scripts/supervisor/gogs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[program:gogs]&#10;directory=/home/git/go/src/github.com/gogits/gogs/&#10;command=/home/git/go/src/github.com/gogits/gogs/gogs web&#10;autostart=true&#10;autorestart=true&#10;startsecs=10&#10;stdout_logfile=/var/log/gogs/stdout.log&#10;stdout_logfile_maxbytes=1MB&#10;stdout_logfile_backups=10&#10;stdout_capture_maxbytes=1MB&#10;stderr_logfile=/var/log/gogs/stderr.log&#10;stderr_logfile_maxbytes=1MB&#10;stderr_logfile_backups=10&#10;stderr_capture_maxbytes=1MB&#10;user = git&#10;environment = HOME=&#34;/home/git&#34;, USER=&#34;git&#34;</span><br></pre></td></tr></table></figure>
<p>修改一些文件路径及参数后就能够直接使用该文件在supervisor中设置Gogs的自动启动。</p>
</li>
<li>Gogs的托管的仓库文件默认位于<code>~/gogs-repositories/</code>文件夹中。</li>
</ol>
<h1 id="利用DropBox备份服务器文件">利用DropBox备份服务器文件</h1><p>通过自建的Git服务器来托管代码后，定时备份数据文件就显得格外重要了。一旦服务器出现故障而无法恢复，所有已上传的代码库也将丢失。<a href="https://db.tt/829rVOUg" target="_blank" rel="external">DropBox</a>是国外非常受信赖的云同步服务，虽然DropBox提供的免费空间较小，但用来备份个人代码文件还是足够的。而且DropBox提供了完善的API接口，可以通过命令行直接上传下载文件，当服务器位于海外时同步速度也十分令人满意。下面介绍如何将服务器中的数据备份至DropBox中。</p>
<h2 id="创建DropBox应用">创建DropBox应用</h2><p>首先需要创建一个DropBox应用来利用DropBox的API，直接点击该网址创建：<a href="https://www.dropbox.com/developers/apps/create" target="_blank" rel="external">https://www.dropbox.com/developers/apps/create</a>。
创建应用时的一些选项如下：</p>
<ul>
<li>Choose an API（应用类型）：DropBox API</li>
<li>Choose the type of access you need（数据访问类型）：App folder</li>
<li>Name your app（应用名称，取一个喜欢的即可）：GogsBackup</li>
</ul>
<p>应用创建后就可以获得<code>App key</code>和<code>App sercet</code>，保存这两行字符。</p>
<h2 id="获取并设置DropBox上传下载脚本">获取并设置DropBox上传下载脚本</h2><p><a href="https://github.com/andreafabrizi/Dropbox-Uploader/" target="_blank" rel="external">Dropbox-Uploader</a>是一个第三方的DropBox上传下载脚本。首先获取该脚本并为其设置可执行权限：
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/tennfy/Dropbox-Uploader/master/dropbox_uploader.sh</span><br><span class="line">chmod a+x dropbox_uploader.sh</span><br></pre></td></tr></table></figure></p>
<p>直接运行该脚本，第一次运行时会连接DropBox验证权限。
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./dropbox_uploader.sh</span><br></pre></td></tr></table></figure></p>
<p>按照提示输入上文中保存的<code>App key</code>和<code>App sercet</code>，Permission type选择<code>a</code>。然后在浏览器中打开给出的连接地址，给予权限。以后运行时就不用再次验证了。
<em>注意</em>：这个授权的过程只是针对当前登陆ssh的用户，并非全局，如果切换用户运行脚本，会提示再次进行授权，因此应提前切换到需要运行该脚本的用户进行授权。其实当前用户的授权信息保存在<code>~/.dropbox_uploader</code>文件中，因此切换用户后会提示首次运行需要进行授权。</p>
<h2 id="备份脚本">备份脚本</h2><p>参考<a href="http://www.tennfy.com/3343.html" target="_blank" rel="external">定时备份VPS数据至Dropbox教程</a>给出的备份脚本，修改相应参数即可。
<figure class="highlight sh"><figcaption><span>backup.sh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 指定dropbox_uploader.sh脚本的保存目录</span></span><br><span class="line">SCRIPT_DIR=<span class="string">"/root/backup"</span></span><br><span class="line"><span class="comment"># 上传到DropBox的文件夹</span></span><br><span class="line">DROPBOX_DIR=<span class="string">"/backup/<span class="variable">$(date +"%Y.%m.%d")</span>"</span></span><br><span class="line"><span class="comment"># 需要保存的服务器文件夹，可以用空格隔开多个文件夹</span></span><br><span class="line">BACKUP_SRC=<span class="string">"/home/git/gogs-repositories"</span></span><br><span class="line"><span class="comment"># 服务器上临时的备份保存文件夹</span></span><br><span class="line">LOCAL_BAK_DIR=<span class="string">"/root/backup"</span></span><br><span class="line"><span class="comment"># MySQL相应配置</span></span><br><span class="line">MYSQL_SERVER=<span class="string">"localhost"</span></span><br><span class="line">MYSQL_USER=<span class="string">"root"</span></span><br><span class="line">MYSQL_PASS=<span class="string">"1325xlg"</span></span><br><span class="line"><span class="comment"># 数据备份压缩后的文件名称</span></span><br><span class="line">DBBakName=Data_$(date +<span class="string">"%Y%m%d"</span>).tar.gz</span><br><span class="line">WebBakName=Web_$(date +<span class="string">"%Y%m%d"</span>).tar.gz</span><br><span class="line"><span class="comment"># 已过期备份数据的名称（3天前的数据会被删除）</span></span><br><span class="line">Old_DROPBOX_DIR=<span class="string">"/backup/<span class="variable">$(date -d -3day +"%Y.%m.%d")</span>"</span></span><br><span class="line">OldDBBakName=Data_$(date <span class="operator">-d</span> -<span class="number">3</span>day +<span class="string">"%Y%m%d"</span>).tar.gz</span><br><span class="line">OldWebBakName=Web_$(date <span class="operator">-d</span> -<span class="number">3</span>day +<span class="string">"%Y%m%d"</span>).tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出MySQL数据库备份（所有数据库），并压缩为指定文件名</span></span><br><span class="line">mysqldump -u <span class="variable">$MYSQL_USER</span> -h <span class="variable">$MYSQL_SERVER</span> -p<span class="variable">$MYSQL_PASS</span> --events --all-databases &gt; <span class="variable">$LOCAL_BAK_DIR</span>/Database.sql</span><br><span class="line">tar zcvf <span class="variable">$LOCAL_BAK_DIR</span>/<span class="variable">$DBBakName</span> <span class="variable">$LOCAL_BAK_DIR</span>/Database.sql</span><br><span class="line">rm -rf <span class="variable">$LOCAL_BAK_DIR</span>/Database.sql</span><br><span class="line"><span class="comment"># 压缩需要保存的文件夹为指定文件名</span></span><br><span class="line">tar zcvf <span class="variable">$LOCAL_BAK_DIR</span>/<span class="variable">$WebBakName</span> <span class="variable">$BACKUP_SRC</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传压缩后的备份文件到指定的DropBox目录</span></span><br><span class="line"><span class="variable">$SCRIPT_DIR</span>/dropbox_uploader.sh upload <span class="variable">$LOCAL_BAK_DIR</span>/<span class="variable">$DBBakName</span> <span class="variable">$DROPBOX_DIR</span>/<span class="variable">$DBBakName</span></span><br><span class="line"><span class="variable">$SCRIPT_DIR</span>/dropbox_uploader.sh upload <span class="variable">$LOCAL_BAK_DIR</span>/<span class="variable">$WebBakName</span> <span class="variable">$DROPBOX_DIR</span>/<span class="variable">$WebBakName</span></span><br><span class="line"><span class="built_in">echo</span> <span class="operator">-e</span> <span class="string">"upload done!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传完成后删除服务器上及DropBox中已经过期的备份数据，节省空间</span></span><br><span class="line">rm -rf <span class="variable">$LOCAL_BAK_DIR</span>/<span class="variable">$OldDBBakName</span> <span class="variable">$LOCAL_BAK_DIR</span>/<span class="variable">$OldWebBakName</span></span><br><span class="line"><span class="variable">$SCRIPT_DIR</span>/dropbox_uploader.sh delete <span class="variable">$Old_DROPBOX_DIR</span>/</span><br><span class="line"><span class="built_in">echo</span> <span class="operator">-e</span> <span class="string">"delete old backup done"</span></span><br></pre></td></tr></table></figure>
然后为该脚本增加运行权限：
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x ./backup.sh</span><br></pre></td></tr></table></figure></p>
<p>现在可以直接运行该脚本，测试其是否能够成功备份文件并上传至DropBox。</p>
<h2 id="设置备份脚本定时运行">设置备份脚本定时运行</h2><p>通过cron程序可以设定程序定时运行。需要注意的是cron运行是分用户的，某个用户设定的定时任务运行时会以该用户的权限运行。因此要注意上文中提到的dropbox_uploader运行用户的问题。
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su root <span class="comment"># 切换到合适用户执行定时任务</span></span><br><span class="line">crontab <span class="operator">-e</span></span><br></pre></td></tr></table></figure></p>
<p>编辑定时任务，文件注释中有十分详细的说明：
<figure class="highlight plain"><figcaption><span>crontab -e</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Edit this file to introduce tasks to be run by cron.&#10;#&#10;# Each task to run has to be defined through a single line&#10;# indicating with different fields when the task will be run&#10;# and what command to run for the task&#10;#&#10;# To define the time you can provide concrete values for&#10;# minute (m), hour (h), day of month (dom), month (mon),&#10;# and day of week (dow) or use &#39;*&#39; in these fields (for &#39;any&#39;).#&#10;# Notice that tasks will be started based on the cron&#39;s system&#10;# daemon&#39;s notion of time and timezones.&#10;#&#10;# Output of the crontab jobs (including errors) is sent through&#10;# email to the user the crontab file belongs to (unless redirected).&#10;#&#10;# For example, you can run a backup of all your user accounts&#10;# at 5 a.m every week with:&#10;# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/&#10;#&#10;# For more information see the manual pages of crontab(5) and cron(8)&#10;#&#10;# m h  dom mon dow   command#&#10;0 3 * * * /bin/bash /root/backup/backup.sh</span><br></pre></td></tr></table></figure>
以上命令表示每天早上3:00执行命令<code>/bin/bash /root/backup/backup.sh</code>。
如果没有设置服务器时区或者不知道服务器时间，可以通过命令<code>date</code>来查看服务器的当前时间。
设置完成后，重启cron服务：
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service cron restart</span><br></pre></td></tr></table></figure></p>
<p>然后，定时任务就会自动执行了。</p>
<p>参考文章：</p>
<ol>
<li><a href="https://mynook.info/blog/post/host-your-own-git-server-using-gogs" target="_blank" rel="external">使用 Gogs 搭建自己的 Git 服务器</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-gogs-on-ubuntu-14-04" target="_blank" rel="external">How To Set Up Gogs on Ubuntu 14.04</a></li>
<li><a href="http://my.oschina.net/luyao/blog/375654?fromerr=xhqsCTAb" target="_blank" rel="external">阿里云上Ubuntu14.04-64位安装Gogs</a></li>
<li><a href="http://keenwon.com/449.html" target="_blank" rel="external">自动定时备份VPS – 如何搭建个人网站</a></li>
<li><a href="http://www.tennfy.com/3343.html" target="_blank" rel="external">定时备份VPS数据至Dropbox教程</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Git是非常流行的版本管理系统，很多的网站也提供了免费的Git服务，如全球知名的最大源代码托管服务<a href="http://github.com">Github</a>。但是大部分的Git源代码托管服务都只对开放的代码托管免费，对私有的代码托管需要收取一定费用。同时，个人的一些代码有时由于各种原因可能并不适合开放，比如：练习用代码，对Git服务提供商的隐私性及安全性有所担忧，包含一些商业机密等等。此时可以搭建自己的Git服务器来托管代码。]]>
    
    </summary>
    
      <category term="git" scheme="https://libhappy.com/tags/git/"/>
    
      <category term="gogs" scheme="https://libhappy.com/tags/gogs/"/>
    
      <category term="vps" scheme="https://libhappy.com/tags/vps/"/>
    
      <category term="备份" scheme="https://libhappy.com/tags/%E5%A4%87%E4%BB%BD/"/>
    
      <category term="Linux" scheme="https://libhappy.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux服务器的简单防护]]></title>
    <link href="https://libhappy.com/2015/12/vps-protect/"/>
    <id>https://libhappy.com/2015/12/vps-protect/</id>
    <published>2015-12-14T01:59:04.000Z</published>
    <updated>2016-01-29T05:27:12.000Z</updated>
    <content type="html"><![CDATA[<p>在购买自己的VPS之后，首先要做好的就是安全防护工作，本文将主要介绍以下方式来提高VPS的安全防护能力：</p>
<ul>
<li>修改ssh默认端口，开启密钥登陆并关闭简单密码登录</li>
<li>开启iptables防火墙，关闭不必要端口的入站连接</li>
</ul>
<a id="more"></a>
<!--toc-->
<h1 id="ssh设置">ssh设置</h1><h2 id="修改默认端口">修改默认端口</h2><p>修改/etc/ssh/sshd_config文件：
<figure class="highlight vhdl"><figcaption><span>/etc/ssh/sshd_config</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># What ports, IPs <span class="keyword">and</span> protocols we listen <span class="keyword">for</span></span><br><span class="line"><span class="keyword">Port</span> <span class="number">12345</span></span><br></pre></td></tr></table></figure></p>
<p>将ssh默认端口<code>22</code>改为一个随机的端口。
注意：小于<code>1024</code>的端口为系统默认分配给特定服务的端口，不建议随意占用。</p>
<h2 id="禁用root登陆">禁用root登陆</h2><p>开启root用户登录使得攻击者可以轻易的猜到可登陆的用户名，同时使用高权限用户操作，如果操作错误容易引起无法恢复的系统错误。因此建议新建一个普通用户登陆，并加入sudo组，在需要时可执行高权限命令，或者直接切换到root用户操作。</p>
<h3 id="新建用户">新建用户</h3><p>新建用户testuser:
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adduser testuser</span><br></pre></td></tr></table></figure></p>
<p>接下来会提示输入该用户的相关信息，显示如下：
<figure class="highlight crmsh"><figcaption><span>adduser testuser</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Adding <span class="keyword">user</span> <span class="title">`testuser</span>' ...</span><br><span class="line">Adding new <span class="keyword">group</span> <span class="title">`testuser</span>' (<span class="number">1001</span>) ...</span><br><span class="line">Adding new <span class="keyword">user</span> <span class="title">`testuser</span>' (<span class="number">1001</span>) with <span class="keyword">group</span> <span class="title">`testuser</span>' ...</span><br><span class="line">Creating home directory `/home/testuser' ...</span><br><span class="line">Copying files from `/etc/skel' ...</span><br><span class="line">Enter new UNIX password:</span><br><span class="line">Retype new UNIX password:</span><br><span class="line">passwd: password updated successfully</span><br><span class="line">Changing the <span class="keyword">user</span> <span class="title">information</span> for testuser</span><br><span class="line">Enter the new value, <span class="operator">or</span> press ENTER for the default</span><br><span class="line">    Full Name []:</span><br><span class="line">    Room <span class="type">Number</span> []:</span><br><span class="line">    Work Phone []:</span><br><span class="line">    Home Phone []:</span><br><span class="line">    Other []:</span><br><span class="line">Is the <span class="number">inf</span>ormation correct? [Y/n] y</span><br></pre></td></tr></table></figure>
按照提示输入相关信息后，确认信息正确，则该用户创建完成。</p>
<h3 id="将用户加入sudo组">将用户加入sudo组</h3><p>将用户加入sudo组，在需要执行高权限命令时可以直接在命令前加sudo执行。给某用户赋予sudo权限需要修改/etc/sudoers文件，但是sudoers文件一旦修改错误易造成系统权限混乱，因此不建议直接修改sudoers文件。事实上sudoers文件默认对所有用户（包括root用户）都是只读权限。修改sudoers文件建议通过程序<strong>visudo</strong>进行，visudo在修改sudoers文件之前会对用户的更改进行检测，当没有出现错误时再将修改写入sudoers文件。
以管理员权限执行命令visudo
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visudo</span><br></pre></td></tr></table></figure></p>
<p>在<code># User privilege specification</code>行下加入如下行：
<figure class="highlight apache"><figcaption><span>visudo</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># User privilege specification</span></span><br><span class="line"><span class="keyword">root</span>    <span class="literal">ALL</span>=(<span class="literal">ALL</span>:<span class="literal">ALL</span>) <span class="literal">ALL</span></span><br><span class="line"><span class="keyword">testuser</span>  <span class="literal">ALL</span>=(<span class="literal">ALL</span>:<span class="literal">ALL</span>) <span class="literal">ALL</span> # 加入这一行</span><br></pre></td></tr></table></figure>
保存退出。</p>
<h3 id="禁用root登陆-1">禁用root登陆</h3><p>修改sshd_config文件，禁用root登陆
<figure class="highlight nginx"><figcaption><span>/etc/ssh/sshd_config</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">PermitRootLogin</span> <span class="built_in">no</span></span><br></pre></td></tr></table></figure></p>
<p>然后重启ssh使配置生效：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/ssh restart</span><br></pre></td></tr></table></figure></p>
<p>注意：以上每次修改sshd_config后都可以重启ssh，然后退出当前ssh连接，再按照新的配置登陆ssh，以验证配置的正确。</p>
<h2 id="禁用简单密码登录，使用密钥登陆">禁用简单密码登录，使用密钥登陆</h2><p>禁用简单密码登录能够防止对服务器猜测密码的暴力破解。</p>
<h3 id="创建密钥">创建密钥</h3><p>首先要创建使用rsa算法加密的公私密钥：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure></p>
<p>输出如下：
<figure class="highlight gherkin"><figcaption><span>ssh-keygen -t rsa</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/home/testuser/.ssh/id_rsa):</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in ./test_rsa.</span><br><span class="line">Your public key has been saved in ./test_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx testuser<span class="comment">@vps</span></span><br><span class="line">The key's randomart image is:</span><br><span class="line">+--[ RSA 2048]----+</span><br><span class="line">|<span class="string">          xx.    </span>|</span><br><span class="line">|<span class="string"> .       ..      </span>|</span><br><span class="line">|<span class="string">  .x***..        </span>|</span><br><span class="line">|<span class="string">       .  .  *   </span>|</span><br><span class="line">|<span class="string">  ==   .-.       </span>|</span><br><span class="line">|<span class="string">     .    x      </span>|</span><br><span class="line">|<span class="string">X.  + &gt;_&lt;!       </span>|</span><br><span class="line">|<span class="string"> .X  *= - x      </span>|</span><br><span class="line">|<span class="string">.. ..+**         </span>|</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure></p>
<p>会提示输入密钥保存的位置与名称、密钥密码，密钥密码用以保护密钥，在使用密钥时同时需要输入该密码。如果私钥被窃取，没有密码也无法使用该密钥。如果不想要密码，在要求设置密码时直接按回车键跳过密码输入。</p>
<h3 id="上传公钥至服务器">上传公钥至服务器</h3><p>生成公私钥后，将公钥上传至服务器。如果是在服务器生成的密钥，则需要将私钥传回客户端并删除服务器上的私钥。
使用 scp 命令上传公钥：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp ./ssh/id_rsa.pub usertest@remote_ssh:</span><br></pre></td></tr></table></figure></p>
<h3 id="设置密钥">设置密钥</h3><p>将上传的公钥保存到当前用户的<code>~/.ssh</code>目录下，并重命名为authorized_keys
<figure class="highlight stylus"><figcaption><span>~</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv id_rsa<span class="class">.pub</span> ./.ssh/authorized_keys</span><br></pre></td></tr></table></figure></p>
<p>同时，为了安全可以设置.ssh目录以及authorized_keys的权限
<figure class="highlight cpp"><figcaption><span>~</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="number">700</span> -R .ssh</span><br><span class="line">chmod <span class="number">400</span> ./.ssh/authorized_keys</span><br></pre></td></tr></table></figure></p>
<h3 id="启用密钥并禁用密码登录">启用密钥并禁用密码登录</h3><p>编辑/etc/ssh/sshd_config文件，修改以下项目：
<figure class="highlight nginx"><figcaption><span>/etc/ssh/sshd_config</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">RSAAuthentication</span> <span class="built_in">yes</span>      <span class="comment">#RSA认证</span></span><br><span class="line">PubkeyAuthentication <span class="built_in">yes</span>   <span class="comment">#开启公钥验证</span></span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys <span class="comment">#验证文件路径</span></span><br><span class="line">PasswordAuthentication <span class="built_in">no</span>  <span class="comment">#禁止密码认证</span></span><br><span class="line">PermitEmptyPasswords <span class="built_in">no</span>    <span class="comment">#禁止空密码</span></span><br><span class="line">UsePAM <span class="built_in">no</span>                  <span class="comment">#禁用PAM</span></span><br></pre></td></tr></table></figure></p>
<p>然后保存，重启ssh服务
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/ssh restart</span><br></pre></td></tr></table></figure></p>
<p>现在，退出当前ssh连接，使用密钥就可以登录服务器了。</p>
<h1 id="iptables防火墙设置">iptables防火墙设置</h1><p>Ubuntu自带了非常简单但功能强大的防火墙iptables，如果不配置规则，默认是允许所有流量的。</p>
<h2 id="查看iptables列表">查看iptables列表</h2><p>用以下命令可以查看已经生效的iptables规则：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -L</span><br></pre></td></tr></table></figure></p>
<p>显示如下：
<figure class="highlight lisp"><figcaption><span>sudo iptables -L</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Chain INPUT <span class="list">(<span class="keyword">policy</span> ACCEPT)</span></span><br><span class="line">target     prot opt source               destination</span><br><span class="line"></span><br><span class="line">Chain FORWARD <span class="list">(<span class="keyword">policy</span> ACCEPT)</span></span><br><span class="line">target     prot opt source               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT <span class="list">(<span class="keyword">policy</span> ACCEPT)</span></span><br><span class="line">target     prot opt source               destination</span><br></pre></td></tr></table></figure></p>
<p>默认是没有任何规则的。也可以加上<code>-v</code>选项查看更为详细的信息。
命令ifconfig可以查看网络接口信息:
<figure class="highlight cpp"><figcaption><span>ifconfig</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  Mask:<span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">          inet6 addr: ::<span class="number">1</span>/<span class="number">128</span> Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:<span class="number">65536</span>  Metric:<span class="number">1</span></span><br><span class="line">          RX packets:<span class="number">0</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> frame:<span class="number">0</span></span><br><span class="line">          TX packets:<span class="number">0</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> carrier:<span class="number">0</span></span><br><span class="line">          collisions:<span class="number">0</span> txqueuelen:<span class="number">0</span></span><br><span class="line">          RX bytes:<span class="number">0</span> (<span class="number">0.0</span> B)  TX bytes:<span class="number">0</span> (<span class="number">0.0</span> B)</span><br><span class="line"></span><br><span class="line">venet0    Link encap:UNSPEC  HWaddr <span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span></span><br><span class="line">          inet addr:<span class="number">127.0</span><span class="number">.0</span><span class="number">.2</span>  P-t-P:<span class="number">127.0</span><span class="number">.0</span><span class="number">.2</span>  Bcast:<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>  Mask:<span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">          UP BROADCAST POINTOPOINT RUNNING NOARP  MTU:<span class="number">1500</span>  Metric:<span class="number">1</span></span><br><span class="line">          RX packets:<span class="number">7054342</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> frame:<span class="number">0</span></span><br><span class="line">          TX packets:<span class="number">5911869</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> carrier:<span class="number">0</span></span><br><span class="line">          collisions:<span class="number">0</span> txqueuelen:<span class="number">0</span></span><br><span class="line">          RX bytes:<span class="number">9292344012</span> (<span class="number">9.2</span> GB)  TX bytes:<span class="number">1060426275</span> (<span class="number">1.0</span> GB)</span><br><span class="line"></span><br><span class="line">venet0:<span class="number">0</span>  Link encap:UNSPEC  HWaddr <span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span>-<span class="number">00</span></span><br><span class="line">          inet addr:<span class="number">192.1</span><span class="number">.2</span><span class="number">.3</span>  P-t-P:<span class="number">192.1</span><span class="number">.2</span><span class="number">.3</span>  Bcast:<span class="number">192.1</span><span class="number">.2</span><span class="number">.3</span>  Mask:<span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br><span class="line">          UP BROADCAST POINTOPOINT RUNNING NOARP  MTU:<span class="number">1500</span>  Metric:<span class="number">1</span></span><br></pre></td></tr></table></figure>
其中<code>lo</code>代表本地回环地址，<code>venet0</code>是OpenVZ架构虚拟机中的第一块虚拟网卡，<code>venet0:0</code>是venet0的别名。</p>
<h2 id="iptables_命令解释">iptables 命令解释</h2><p>iptables常用命令解释：</p>
<ul>
<li>-A chain, –append  添加一条新规则</li>
<li>-D chain [rulenumder], –delete  删除一条规则</li>
<li>-I chain [rulenumder], –insert  插入一条规则</li>
<li>-R chain [rulenumber], –replace  替换一条规则</li>
<li>-L [chain [rulenumber]], –list  列出所有规则</li>
<li>-P, –policy 策略</li>
<li>-i, –in-interface  网络接口名称</li>
<li>-m match, –match  扩展匹配</li>
<li>-p proto, –protocol  协议，如’tcp’，’udp’</li>
<li>-j target, –jump 参数用来指定要进行的处理动作，常用的处理动作包括：ACCEPT、REJECT、DROP、REDIRECT、MASQUERADE等</li>
</ul>
<p>链(chain)：链是一些按顺序排列的规则的列表，iptables 默认的 filter 表包含 INPUT， OUTPUT 和 FORWARD 3条内建的链。</p>
<h2 id="允许连接">允许连接</h2><p>首先允许本地回环端口
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -A INPUT -i lo -j ACCEPT</span><br></pre></td></tr></table></figure></p>
<p>允许建立关联连接
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br></pre></td></tr></table></figure></p>
<p>允许访问特定端口
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -A INPUT -p tcp --dport <span class="number">12345</span> -j ACCEPT</span><br></pre></td></tr></table></figure></p>
<p>如，允许ssh端口：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -A INPUT -p tcp --dport <span class="number">22</span> -j ACCEPT</span><br><span class="line"><span class="comment"># 如果更改了默认ssh端口要更改为修改后的端口（如上文中的12345）</span></span><br></pre></td></tr></table></figure></p>
<p>允许FTP端口：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -A INPUT -p tcp --dport <span class="number">21</span> -j ACCEPT</span><br><span class="line">sudo iptables -A INPUT -p tcp --dport <span class="number">20</span> -j ACCEPT</span><br></pre></td></tr></table></figure></p>
<p>同时开放多个端口：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -A INPUT -p tcp -m multiport --dport <span class="number">20</span>,<span class="number">21</span> -j ACCEPT</span><br></pre></td></tr></table></figure></p>
<p>允许接收ping
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -A INPUT -p icmp --icmp-type <span class="built_in">echo</span>-request -j ACCEPT</span><br></pre></td></tr></table></figure></p>
<p>接收ping后可以通过ping命令在本地服务端测试网络延迟，但是也会使其他人通过ping来知晓该服务器地址的可用性，如无特殊需要可以不接受所有ping。</p>
<h2 id="阻止其他连接">阻止其他连接</h2><p>最后，在以上允许连接的基础上阻止所有其他连接：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -A INPUT -j REJECT</span><br><span class="line">sudo iptables -A FORWARD -j REJECT</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：在阻止所有连接之前一定要将允许ssh端口的连接，否则规则生效后会直接断开ssh连接并且无法重新连接。这时只能进入管理后台取消该阻止规则，或者重装系统。</p>
<h2 id="编辑已存在规则">编辑已存在规则</h2><p>将所有的iptables规则以序号标记显示：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -L -n --line-numbers</span><br></pre></td></tr></table></figure></p>
<p>显示如下：
<figure class="highlight sql"><figcaption><span>sudo iptables -L -n --line-numbers</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">num  target     prot opt source               destination</span><br><span class="line">1    ACCEPT     tcp  <span class="comment">--  0.0.0.0/0            0.0.0.0/0            tcp dpt:12345</span></span><br><span class="line">2    ACCEPT     all  <span class="comment">--  0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED</span></span><br><span class="line">3    ACCEPT     tcp  <span class="comment">--  0.0.0.0/0            0.0.0.0/0            tcp dpt:20</span></span><br><span class="line">4    ACCEPT     udp  <span class="comment">--  0.0.0.0/0            0.0.0.0/0            multiport dports 2000,3000</span></span><br><span class="line">5    ACCEPT     all  <span class="comment">--  0.0.0.0/0            0.0.0.0/0</span></span><br><span class="line">6    <span class="operator"><span class="keyword">DROP</span>       all  <span class="comment">--  0.0.0.0/0            0.0.0.0/0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Chain</span> FORWARD (<span class="keyword">policy</span> <span class="keyword">ACCEPT</span>)</span><br><span class="line"><span class="keyword">num</span>  target     prot opt <span class="keyword">source</span>               destination</span><br><span class="line"></span><br><span class="line"><span class="keyword">Chain</span> <span class="keyword">OUTPUT</span> (<span class="keyword">policy</span> <span class="keyword">ACCEPT</span>)</span><br><span class="line"><span class="keyword">num</span>  target     prot opt <span class="keyword">source</span>               destination</span></span><br></pre></td></tr></table></figure></p>
<p>现在INPUT 链中已经有6条规则了，现在来修改已经存在的规则。</p>
<h3 id="删除一条规则">删除一条规则</h3><p>比如：删除第6条规则
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -D INPUT <span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<h3 id="插入一条规则">插入一条规则</h3><p>在第2条规则之前插入一条规则
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -I INPUT <span class="number">2</span> -p tcp -i venet0 --dport <span class="number">1234</span> -j ACCEPT</span><br></pre></td></tr></table></figure></p>
<h2 id="保存规则与恢复规则">保存规则与恢复规则</h2><p>在Ubuntu上 iptables 默认是不会保存已经设置的规则，系统重启后所有规则将丢失，所以需要将已有规则保存下来。</p>
<h3 id="手动保存规则">手动保存规则</h3><figure class="highlight stata"><figcaption><span>root #</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 由于sudo只作用于其后跟的第一个命令，所以以下命令中<span class="string">"&gt;"</span>会因为没有写入权限而无法运行，所以直接切换到root用户运行命令。</span><br><span class="line"><span class="keyword">su</span> root</span><br><span class="line">iptables-<span class="keyword">save</span> &gt; /etc/iptables.<span class="keyword">input</span>.rules</span><br></pre></td></tr></table></figure>
<p>保存规则后，设置开机自动从文件恢复规则。编辑开机启动文件/etc/rc.local
在<code>exit 0</code>之前写入以下命令
<figure class="highlight sql"><figcaption><span>/etc/rc.local</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables-<span class="operator"><span class="keyword">restore</span> &lt; /etc/iptables.<span class="keyword">input</span>.<span class="keyword">rules</span></span></span><br></pre></td></tr></table></figure>
保存退出。</p>
<h3 id="自动保存规则">自动保存规则</h3><p>让网卡关闭时自动保存规则，网卡开启时自动恢复规则。
创建/etc/network/if-post-down.d/iptables 文件，添加如下内容：
<figure class="highlight bash"><figcaption><span>/etc/network/if-post-down.d/iptables</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span></span><br><span class="line">iptables-save &gt; /etc/iptables.input.rules</span><br></pre></td></tr></table></figure>
为文件添加执行权限：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /etc/network/<span class="keyword">if</span>-post-down.d/iptables</span><br></pre></td></tr></table></figure></p>
<p>创建/etc/network/if-pre-up.d/iptables 文件，添加如下内容：
<figure class="highlight bash"><figcaption><span>/etc/network/if-pre-up.d/iptables</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span></span><br><span class="line">iptables-restore &lt; /etc/iptables.input.rules</span><br></pre></td></tr></table></figure>
为文件添加执行权限：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /etc/network/<span class="keyword">if</span>-pre-up.d/iptables</span><br></pre></td></tr></table></figure></p>
<p>当网络关闭或开启时就会自动保存与恢复iptables规则。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在购买自己的VPS之后，首先要做好的就是安全防护工作，本文将主要介绍以下方式来提高VPS的安全防护能力：</p>
<ul>
<li>修改ssh默认端口，开启密钥登陆并关闭简单密码登录</li>
<li>开启iptables防火墙，关闭不必要端口的入站连接</li>
</ul>]]>
    
    </summary>
    
      <category term="Linux" scheme="https://libhappy.com/tags/Linux/"/>
    
      <category term="iptables" scheme="https://libhappy.com/tags/iptables/"/>
    
      <category term="ssh" scheme="https://libhappy.com/tags/ssh/"/>
    
      <category term="vps" scheme="https://libhappy.com/tags/vps/"/>
    
      <category term="Linux" scheme="https://libhappy.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用Hexo搭建静态博客（三）, 设置自定义域名]]></title>
    <link href="https://libhappy.com/2015/10/build-hexo-blog3/"/>
    <id>https://libhappy.com/2015/10/build-hexo-blog3/</id>
    <published>2015-10-30T14:32:02.000Z</published>
    <updated>2016-03-16T09:51:57.000Z</updated>
    <content type="html"><![CDATA[<p>在之前的文章中介绍了如何<a href="/2015/10/bulid-hexo-blog1/">用hexo来搭建静态博客</a>以及<a href="/2015/10/bulid-hexo-blog2/">将网页部署至github及gitcafe</a>。完成部署之后，可以通过github及gitcafe分配的pages二级域名来访问博客，比如<code>username.github.io</code>。通过将自己的博客绑定至自己购买的域名可以更加方便的访问，下面将介绍如何购买一个域名及将自定义域名绑定至github及gitcafe。
<a id="more"></a>
<!--toc--></p>
<h1 id="购买域名">购买域名</h1><p>首先要购买一个域名，推荐比较出名的国外域名服务商，比如<a href="https://www.godaddy.com/" target="_blank" rel="external">GoDaddy</a>。其他的如<a href="https://www.namesilo.com/" target="_blank" rel="external">namesilo</a>、<a href="https://www.name.com/" target="_blank" rel="external">name.com</a>价格比较便宜, 当然国内的域名提供商也是可以的。</p>
<h1 id="设置域名解析服务">设置域名解析服务</h1><p>购买到心仪的域名后进入域名设置页面设置域名解析服务。由于godaddy的域名解析服务位于国外，速度稍有影响，因此可以使用国内的免费域名解析服务<a href="https://www.dnspod.cn/" target="_blank" rel="external">DNSPod</a>，同时DNSPod还支持根据不同线路解析到不同地址，因此可以利用此功能针对不同地区的访问者分别解析到github及gitcafe以提高访问速度。</p>
<p>使用DNSPod来进行域名解析首先要将域名解析服务商(nameserver)地址更换为DNSPod提供的地址:
<figure class="highlight plain"><figcaption><span>nameserver</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F1G1NS1.DNSPOD.NET&#10;F1G1NS2.DNSPOD.NET</span><br></pre></td></tr></table></figure></p>
<p>GoDaddy的具体设置可以查看DNSPod上的<a href="https://support.dnspod.cn/Kb/showarticle/?qtype=%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B&amp;tsid=42" target="_blank" rel="external">帮助教程</a>。</p>
<h1 id="设置CNAME">设置CNAME</h1><h2 id="github设置CNAME">github设置CNAME</h2><p>github的CNAME设置需要在github pages 的根目录下创建CNAME文件并在其中写入自定义域名，但是直接在github pages中创建，下次通过git push提交博客后会被删除。因此需要在Hexo的source目录下的创建CNAME文件，并在其中写入自定义域名。之后每次提交博客时会随之提交CNAME文件。</p>
<h2 id="gitcafe设置CNAME">gitcafe设置CNAME</h2><p>gitcafe的CNAME更为方便，登陆gitcafe后在<code>项目管理</code>–<code>域名管理</code>下的<code>自定义域名</code>中添加自定义域名即可。</p>
<h1 id="设置DNS解析">设置DNS解析</h1><p>最后需要注册DNSPod并设置DNS解析。之前已经在Godaddy中将域名解析服务设置为DNSPod。直接登陆DNSPod，添加自定义域名，在添加的域名中添加如下记录：
<div class="figure center"><img class="fig-img" src="https://farm1.staticflickr.com/678/22594923969_f316996f4b_z.jpg" alt="DNSPod域名解析记录设置"><span class="caption">DNSPod域名解析记录设置</span></div>
这样设置可以区分不同的地区分别访问托管在github及gitcafe上的博客，加快博客访问速度。如果只是使用其中一项服务，只需添加对应记录即可。</p>
<p>等待域名解析生效（一般需要几分钟到一天不等）后，就可以用自定义的域名直接访问博客了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在之前的文章中介绍了如何<a href="/2015/10/bulid-hexo-blog1/">用hexo来搭建静态博客</a>以及<a href="/2015/10/bulid-hexo-blog2/">将网页部署至github及gitcafe</a>。完成部署之后，可以通过github及gitcafe分配的pages二级域名来访问博客，比如<code>username.github.io</code>。通过将自己的博客绑定至自己购买的域名可以更加方便的访问，下面将介绍如何购买一个域名及将自定义域名绑定至github及gitcafe。]]>
    
    </summary>
    
      <category term="hexo" scheme="https://libhappy.com/tags/hexo/"/>
    
      <category term="博客" scheme="https://libhappy.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="域名" scheme="https://libhappy.com/tags/%E5%9F%9F%E5%90%8D/"/>
    
      <category term="Hexo" scheme="https://libhappy.com/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用Hexo搭建静态博客（二）, 将网页部署至github与gitcafe并使用SSH认证]]></title>
    <link href="https://libhappy.com/2015/10/build-hexo-blog2/"/>
    <id>https://libhappy.com/2015/10/build-hexo-blog2/</id>
    <published>2015-10-27T08:31:14.000Z</published>
    <updated>2016-03-16T09:51:18.000Z</updated>
    <content type="html"><![CDATA[<p>在<a href="/2015/10/bulid-hexo-blog1/">上一篇</a>文章中介绍了如何在本地搭建Hexo以及用Hexo书写博客的基本操作。在这篇文章中将介绍如何将创建的博客发布至github及gitcafe的静态页面。通过为github及gitcafe添加ssh验证来跳过推送页面时输入用户名及密码。
<a id="more"></a>
<!--toc--></p>
<h1 id="注册github及gitcafe账号">注册github及gitcafe账号</h1><p>github及gitcafe都支持pages网页托管服务，首先选择要托管的服务注册账号。当然也可以同时将博客发布至github和gitcafe，对于国内及国外不同用户分别访问不同的服务上的博客。</p>
<h1 id="将博客发布至github">将博客发布至github</h1><p>创建github pages的详细方法可以参考官方<a href="https://help.github.com/categories/github-pages-basics/" target="_blank" rel="external">帮助页面</a>。</p>
<h2 id="创建新的代码仓库">创建新的代码仓库</h2><p>新代码仓库(repository)名必须为<code>username.github.io</code>，其中<code>username</code>为注册github的用户名。</p>
<h2 id="设置用户名及邮箱">设置用户名及邮箱</h2><p>Hexo目录下的<code>.deploy_git</code>文件夹即为需要发布的文件，这是一个git目录。在发布至github之前需要先设置git的用户名及邮箱地址。
<figure class="highlight sh"><figcaption><span>D:\hexo\.deploy_git</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"your name"</span></span><br><span class="line">git config --global user.eamil <span class="string">"user@email.com"</span></span><br></pre></td></tr></table></figure></p>
<p>这个命令设置了计算机中全局默认的用户名及邮箱，如果计算机中只有一个git账号的代码，这样设置该账号下的其他仓库时可以不用再进行设置。
但计算机中有多个账号的仓库代码要通过git同步时，就应该只设置该目录下git仓库的用户名及邮箱：
<figure class="highlight sh"><figcaption><span>D:\hexo\.deploy_git</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name <span class="string">"your name"</span></span><br><span class="line">git config user.eamil <span class="string">"your@email"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="设置远程仓库地址">设置远程仓库地址</h2><p>将远程仓库地址设置为新建的代码仓库，然后将网页推送至远程仓库：
<figure class="highlight sh"><figcaption><span>D:\hexo\.deploy_git</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:username.github.io</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></p>
<p>一段时间后，直接访问网址<code>username.github.io</code>就可以看到刚发布的博客了。</p>
<h2 id="设置Hexo配置文件">设置Hexo配置文件</h2><p>配置Hexo的站点配置文件，加入远程仓库的信息，以后更新博客时只用执行 <code>hexo d</code>就可以将博客发布到远端了。
<figure class="highlight plain"><figcaption><span>D:\hexo\_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deploy:&#10;  type: git&#10;  repository: git@github.com:username.github.io #&#20320;&#30340;GitHub Pages&#20179;&#24211;&#10;  branch: master #&#35201;&#25512;&#36865;&#30340;&#20998;&#25903;&#65292;github pages&#40664;&#35748;&#20026;master</span><br></pre></td></tr></table></figure></p>
<h1 id="将博客发布至gitcafe">将博客发布至gitcafe</h1><p>由于github 的连接速度并不理想，如果只是面向国内用户，可以将博客发布至gitcafe的pages服务。详细内容可以查看gitcafe的官方<a href="https://gitcafe.com/GitCafe/Help/wiki/Pages-%E7%9B%B8%E5%85%B3%E5%B8%AE%E5%8A%A9" target="_blank" rel="external">帮助文档</a>，具体操作流程与github大同小异。
需要注意的是：gitcafe pages 的默认分支为<code>gitcafe-pages</code>，因此推送时要使用<code>gitcafe-pages</code>作为远端分支：
<figure class="highlight sh"><figcaption><span>D:\hexo\.deploy_git</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitcafe.com:username.gitcafe.io</span><br><span class="line">git checkout -b gitcafe-pages</span><br><span class="line">git pull origin gitcafe-pages</span><br></pre></td></tr></table></figure></p>
<p>同时Hexo配置文件中的<code>branch</code>也要改为<code>gitcafe-pages</code>。
<figure class="highlight plain"><figcaption><span>D:\hexo\_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deploy:&#10;  type: git&#10;  repository: git@gitcafe.com:username.gitcafe.io #&#20320;&#30340;GitCafe Pages&#20179;&#24211;&#10;  branch: gitcafe-pages #&#35201;&#25512;&#36865;&#30340;&#20998;&#25903;&#65292;gitcafe pages&#40664;&#35748;&#20026;gitcafe-pages</span><br></pre></td></tr></table></figure></p>
<p>发布后稍等片刻，直接访问<code>username.gitcafe.io</code>就可以看到刚发布的博客了。</p>
<h1 id="同时将博客发布至github与gitcafe">同时将博客发布至github与gitcafe</h1><p>如果同时设置了github及gitcafe，也可以将博客同时发布至两个服务。但是本地仓库的信息相同，因此需要使用相同的邮箱注册两个服务。在设置好远端服务后，如下修改Hexo站点配置文件：
<figure class="highlight plain"><figcaption><span>D:\hexo\_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deploy:&#10;  type: git&#10;  repo:&#10;    github: git@github.com:username.github.io, master&#10;    gitcafe: git@gitcafe.com:username.gitcafe.io, gitcafe-pages</span><br></pre></td></tr></table></figure></p>
<p>然后<code>hexo d</code>发布博客后，分别打开对应服务的网址就可以看到发布的博客了。</p>
<h1 id="使用ssh密钥登陆">使用ssh密钥登陆</h1><p>使用ssh密钥登陆github和gitcafe可以跳过密码输入，如果同时拥有两个服务也可以设置不同的密钥登陆，提升安全性。</p>
<h2 id="生成ssh密钥">生成ssh密钥</h2><p>切换到ssh默认的密匙保存目录<code>C:\Users\username\.ssh</code>，如果不存在则手动创建。
用以下命令生成与邮箱<code>user@email.com</code>（即注册github及gitcafe的邮箱）对应的密钥：
<figure class="highlight sh"><figcaption><span>C:\Users\username\.ssh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"user@email.com"</span></span><br></pre></td></tr></table></figure></p>
<p>首先会提示输入密钥名称
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generating public/private rsa key pair.&#10;Enter file in which to save the key (/c/Users/username/.ssh/id_rsa):</span><br></pre></td></tr></table></figure></p>
<p>如果没有设置过ssh密钥，使用默认的<code>id_rsa</code>即可。同时如果想在github及gitcafe上启用不同的密钥，在生成密钥时应采用不同的名称便于区分。
之后会提示输入密钥密码，该密码用来加密密钥，使用此密钥时需要输入该密码，留空则表示不使用密码。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase):&#10;Enter same passphrase again:</span><br></pre></td></tr></table></figure></p>
<p>然后会提示你成功生成了密钥，假设此时生成的密钥对为<code>github_rsa</code>与<code>github_rsa.pub</code>。相应的也可以为gitcafe网站生成不同的密钥对。</p>
<h2 id="将公钥上传至github及gitcafe">将公钥上传至github及gitcafe</h2><p>登陆github，打开<code>Settings</code>中的<code>SSH keys</code>点击<code>Add SSH key</code>，输入SSH key的名称，将.pub文件中的内容全部粘贴至<code>Key</code>中，点击<code>Add key</code>保存这个密钥。
gitcafe 中的设置完全相同，只是其SSH key管理的设置在<code>账户设置</code>–<code>SSH 公钥管理</code>中，相同的方式添加.pub公钥的信息即可。</p>
<h2 id="设置ssh用户配置文件">设置ssh用户配置文件</h2><p>在ssh用户配置文件<code>C:\Users\username\.ssh\config</code>中指定对应服务所使用的私钥，如果该配置文件不存在则直接新建一个。
<figure class="highlight plain"><figcaption><span>C:\Users\username\.ssh\config</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#github&#10;Host github.com  #&#26165;&#31216;&#10;    HostName github.com #&#25351;&#20195;&#30340;&#32593;&#22336;&#10;    User git&#10;    IdentityFile ~/.ssh/github_rsa #&#35748;&#35777;&#31169;&#38053;&#36335;&#24452;&#10;    PreferredAuthentications publickey&#10;&#10;#gitcafe&#10;Host gitcafe.com&#10;    HostName gitcafe.com&#10;    User git&#10;    IdentityFile ~/.ssh/gitcafe_rsa&#10;    PreferredAuthentications publickey</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>其中昵称是对应条目的代号，可以随便设置，在git中如果地址中出现该代号将被替换为对应的<code>HostName</code>并用指定的私钥进行认证。因此若计算机中有两个github账户需要用不同的ssh key进行认证，可以如下设置：
<figure class="highlight plain"><figcaption><span>C:\Users\username\.ssh\config</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#github 01&#10;Host github01  #&#26165;&#31216;&#10;    HostName github.com #&#25351;&#20195;&#30340;&#32593;&#22336;&#10;    User git&#10;    IdentityFile ~/.ssh/01_rsa #&#35748;&#35777;&#31169;&#38053;&#36335;&#24452;&#10;    PreferredAuthentications publickey&#10;&#10;#github 02&#10;Host github02  #&#26165;&#31216;&#10;    HostName github.com #&#25351;&#20195;&#30340;&#32593;&#22336;&#10;    User git&#10;    IdentityFile ~/.ssh/02_rsa #&#35748;&#35777;&#31169;&#38053;&#36335;&#24452;&#10;    PreferredAuthentications publickey</span><br></pre></td></tr></table></figure></p>
<p>在设置git远端地址或登陆时，用对应的昵称代替地址中的<code>github.com</code>，比如：
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github01:username.github.io</span><br><span class="line">git remote add origin git@github02:username.github.io</span><br></pre></td></tr></table></figure></p>
<h2 id="测试_ssh_配置是否正确">测试 ssh 配置是否正确</h2><p>经过以上设置后应该可以用ssh登陆github及gitcafe，用以下命令可以测试配置是否正确。
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试github</span></span><br><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试gitcafe</span></span><br><span class="line">ssh -T git@gitcafe.com</span><br></pre></td></tr></table></figure></p>
<p>如果连接成功，会提示以下信息：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># github&#10;Hi USERNAME! You&#39;ve successfully authenticated, but GitHub does not provide shell access.&#10;&#10;# gitcafe&#10;Hi USERNAME! You&#39;ve successfully authenticated, but GitCafe does not provide shell access.</span><br></pre></td></tr></table></figure></p>
<p>测试通过后，就可以使用ssh key来发布博客及提交代码而无需输入密码了。</p>
<p>本文主要介绍了如何将Hexo博客发布至github及gitcafe，以及配置多对ssh公私钥进行git认证。下一篇文章中将介绍如何购买域名及为托管在github及gitcafe上的博客设置自定义域名。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在<a href="/2015/10/bulid-hexo-blog1/">上一篇</a>文章中介绍了如何在本地搭建Hexo以及用Hexo书写博客的基本操作。在这篇文章中将介绍如何将创建的博客发布至github及gitcafe的静态页面。通过为github及gitcafe添加ssh验证来跳过推送页面时输入用户名及密码。]]>
    
    </summary>
    
      <category term="github" scheme="https://libhappy.com/tags/github/"/>
    
      <category term="hexo" scheme="https://libhappy.com/tags/hexo/"/>
    
      <category term="ssh" scheme="https://libhappy.com/tags/ssh/"/>
    
      <category term="博客" scheme="https://libhappy.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Hexo" scheme="https://libhappy.com/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用Hexo搭建静态博客（一）, Hexo的搭建]]></title>
    <link href="https://libhappy.com/2015/10/bulid-hexo-blog1/"/>
    <id>https://libhappy.com/2015/10/bulid-hexo-blog1/</id>
    <published>2015-10-26T02:38:40.000Z</published>
    <updated>2016-03-16T09:54:11.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://hexo.io/" target="_blank" rel="external">Hexo</a> 是一个基于Node.js的开源静态博客程序，通过markdown书写文章，生成的静态网页可以托管在github及gitcafe上。通过<a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>可以方便的创建自己的博客，本博客即使用Hexo创建并托管在github及gitcafe上。
<a id="more"></a>
<!--toc--></p>
<h1 id="依赖程序的安装">依赖程序的安装</h1><p>Hexo 基于Node.js，其部署通过Git进行，以下程序的安装过程仅以Windows平台为例。</p>
<h2 id="安装_Node-js">安装 Node.js</h2><p>到<a href="https://nodejs.org/" target="_blank" rel="external">Node.js</a> 官网下载安装包，直接双击安装。</p>
<h2 id="安装_Git">安装 Git</h2><p>到<a href="https://git-scm.com/downloads" target="_blank" rel="external">Git</a>官网下载安装包，直接双击安装。</p>
<h2 id="验证安装是否正确">验证安装是否正确</h2><p>在开始菜单中打开<code>Git Bash</code>，输入：
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br><span class="line">git version <span class="number">2.5</span>.<span class="number">2</span>.windows.<span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>如果如上显示正确的版本号则Git 已正确安装。
输入：
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br><span class="line"><span class="number">2.14</span>.<span class="number">7</span></span><br></pre></td></tr></table></figure></p>
<p>显示对应版本号则表示Node.js 已正确安装。</p>
<h1 id="安装与部署_Hexo">安装与部署 Hexo</h1><h2 id="安装Hexo">安装Hexo</h2><p>打开<code>Git Bash</code> 通过npm命令即可安装Hexo：
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure></p>
<h2 id="初始化_Hexo">初始化 Hexo</h2><p>打开<code>Git Bash</code>并切换到想要存放Hexo的目录下，执行以下命令将在该目录下新建文件夹<code>&lt;folder&gt;</code>并在该文件夹中初始化Hexo：
<figure class="highlight plain"><figcaption><span>D:\</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init &#60;folder&#62;&#10;cd &#60;folder&#62;&#10;npm install</span><br></pre></td></tr></table></figure></p>
<p>新建完成后，指定文件夹的目录如下：
<figure class="highlight plain"><figcaption><span>D:\hexo</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#10;&#9500;&#9472;&#9472; _config.yml   #&#20027;&#37197;&#32622;&#25991;&#20214;&#10;&#9500;&#9472;&#9472; package.json  #&#24212;&#29992;&#25968;&#25454;&#65292;&#19981;&#24314;&#35758;&#25163;&#21160;&#20462;&#25913;&#10;&#9500;&#9472;&#9472; .deploy       #&#23558;&#37096;&#32626;&#30340;&#38745;&#24577;&#25991;&#20214;&#65292;&#20026;git&#21516;&#27493;&#30446;&#24405;&#10;&#9500;&#9472;&#9472; node_modules  #Hexo&#23433;&#35013;&#30340;&#25152;&#26377;&#25554;&#20214;&#10;&#9500;&#9472;&#9472; scaffolds     #(&#33050;&#25163;&#26550;)&#26032;&#24314;&#25991;&#31456;&#30340;&#27169;&#26495;&#25991;&#20214;&#10;&#9500;&#9472;&#9472; scripts       #&#33258;&#23450;&#20041;&#30340;&#38543;&#31243;&#24207;&#36816;&#34892;&#30340;&#33050;&#26412;&#25991;&#20214;&#10;&#9500;&#9472;&#9472; source        #&#21338;&#23458;&#28304;&#25991;&#20214;&#65292;&#25991;&#31456;markdown&#25991;&#20214;&#12289;404&#21644;CNAME&#25991;&#20214;&#31561;&#10;|   &#9500;&#9472;&#9472; _drafts   #&#25991;&#31456;&#33609;&#31295;&#65292;&#19981;&#20250;&#34987;&#36716;&#25442;&#20026;html&#10;|   &#9492;&#9472;&#9472; _posts    #&#21457;&#34920;&#30340;&#25991;&#31456;&#10;&#9492;&#9472;&#9472; themes        #&#20027;&#39064;&#25991;&#20214;&#22841;</span><br></pre></td></tr></table></figure></p>
<h2 id="本地查看Hexo_博客">本地查看Hexo 博客</h2><p>执行以下命令打开Hexo 本地服务器
<figure class="highlight plain"><figcaption><span>D:\hexo</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server&#10;INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure></p>
<p>在浏览器中打开网址<code>localhost:4000</code>就可以查看默认的Hexo博客。</p>
<h2 id="安装_Hexo_插件">安装 Hexo 插件</h2><p>Hexo 提供了许多插件以提供不同的功能，<a href="https://hexo.io/plugins/" target="_blank" rel="external">插件列表</a>列出了可用的插件。以安装<a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="external">hexo-generator-feed</a>插件为例。
该插件可以为博客增加rss订阅支持，在博客目录下打开命令行，输入以下命令即可安装该插件：
<figure class="highlight sh"><figcaption><span>D:\hexo</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure></p>
<p>安装完成后在主目录的配置文件中可以配置该插件的功能：
<figure class="highlight plain"><figcaption><span>D:\hexo\_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feed:&#10;  type: atom&#10;  path: atom.xml&#10;  limit: 20</span><br></pre></td></tr></table></figure></p>
<p>然后在页面添加对atom.xml文件的链接即可。
其他插件的功能、安装及配置可以查看<a href="https://hexo.io/plugins/" target="_blank" rel="external">插件列表</a>详细了解。</p>
<h2 id="安装_Hexo_主题">安装 Hexo 主题</h2><p>通过安装不同的主题，可以方便的使博客拥有不同的外观，官方的<a href="https://hexo.io/themes/" target="_blank" rel="external">主题列表</a>列举一些主题。
一款非常流行的Hexo主题<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">NexT</a>:
<iframe src="http://notes.iissnan.com/" width="800" height="600" frameborder="0" allowfullscreen></iframe></p>
<p>另一款流行的主题<a href="https://github.com/wuchong/jacman" target="_blank" rel="external">Jacman</a>:
<iframe src="http://wuchong.me/jacman/" width="800" height="600" frameborder="0" allowfullscreen></iframe></p>
<p>安装Hexo主题十分简单，首先下载主题后解压到主目录下的<code>themes</code>文件夹，建议使用<code>git clone</code>的方式安装主题，便于更新。
以安装NexT主题为例，打开命令行，切换到Hexo主目录下：
<figure class="highlight sh"><figcaption><span>D:\hexo</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p>
<p>完成后，主题已被下载到了<code>themes\next</code>目录下。
当需要更新主题时，执行以下命令即可：
<figure class="highlight sh"><figcaption><span>D:\hexo</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/next</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></p>
<p>之后更改主目录中的配置文件<code>_config.yml</code>应用新主题，修改其中的<code>theme</code>字段的值即可：
<figure class="highlight plain"><figcaption><span>D:\hexo\_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next&#10;# &#27880;&#24847;&#25152;&#26377;&#21442;&#25968;&#21517;&#21518;&#30340;&#20882;&#21495;&#8220;:&#8221;&#21518;&#38754;&#24517;&#39035;&#26377;&#19968;&#20010;&#31354;&#26684;</span><br></pre></td></tr></table></figure></p>
<p>然后重新生成网页文件即可：
<figure class="highlight plain"><figcaption><span>D:\hexo</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># &#28165;&#38500;&#24050;&#32463;&#29983;&#25104;&#30340;&#32531;&#23384;&#32593;&#39029;&#25991;&#20214;&#65292;&#21482;&#26159;&#26032;&#22686;&#25991;&#31456;&#26102;&#21487;&#20197;&#19981;&#25191;&#34892;&#35813;&#21629;&#20196;&#10;hexo clean&#10;# &#29983;&#25104;&#32593;&#39029;&#25991;&#20214;&#65292;&#22914;&#26524;&#29983;&#25104;&#32593;&#39029;&#25991;&#20214;&#26377;&#38382;&#39064;&#65292;&#21487;&#20197;&#23581;&#35797;&#20808;&#25191;&#34892;&#19978;&#19968;&#20010;clean&#21629;&#20196;&#28165;&#38500;&#32531;&#23384;&#20877;&#37325;&#26032;&#29983;&#25104;&#10;hexo generate</span><br></pre></td></tr></table></figure></p>
<p><code>hexo generate</code> 也可以用短命令 <code>hexo g</code> 代替。</p>
<p>之后打开本地服务器，查看应用新主题后的博客效果。
<figure class="highlight plain"><figcaption><span>D:\hexo</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure></p>
<h1 id="Hexo_的使用">Hexo 的使用</h1><p>用Hexo书写博客的流程为：</p>
<ol>
<li><code>hexo new &quot;post-name&quot;</code>按照模板文件生成新的文章，该文件位于<code>source/_posts</code>文件夹中</li>
<li>按照<strong>markdown</strong>语法编辑post-name.md文件</li>
<li><code>hexo generate</code>生成新的网页文件</li>
<li><code>hexo deploy</code>部署生成的网页文件</li>
</ol>
<h2 id="Hexo常用命令">Hexo常用命令</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo help                  <span class="preprocessor">#查看hexo所有命令及帮助</span></span><br><span class="line">hexo init                  <span class="preprocessor">#初始化一个目录</span></span><br><span class="line">hexo <span class="keyword">new</span> <span class="string">"post_Name"</span>       <span class="preprocessor">#新建文章</span></span><br><span class="line">hexo <span class="keyword">new</span> page <span class="string">"page_Name"</span>  <span class="preprocessor">#新建页面</span></span><br><span class="line">hexo generate              <span class="preprocessor">#生成网页, 可以在 public 目录查看整个网站的文件</span></span><br><span class="line">hexo <span class="keyword">server</span>                <span class="preprocessor">#打开本地服务器，预览博客</span></span><br><span class="line">hexo deploy                <span class="preprocessor">#部署生成的博客至远端服务器</span></span><br><span class="line">hexo clean                 <span class="preprocessor">#清除缓存网页文件,如果生成的网页有问题可以用此命令清除缓存后重新生成</span></span><br></pre></td></tr></table></figure>
<p>Hexo 中的某些常用命令还支持简写：
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n &lt;=&gt; hexo <span class="keyword">new</span></span><br><span class="line">hexo g &lt;=&gt; hexo generate</span><br><span class="line">hexo s &lt;=&gt; hexo server</span><br><span class="line">hexo d &lt;=&gt; hexo deploy</span><br></pre></td></tr></table></figure></p>
<p>本文主要介绍了Hexo博客本地应用程序的安装以及基本应用，在下一篇文章中将介绍将Hexo生成的博客部署至github及gitcafe上及自定义域名的绑定。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://hexo.io/">Hexo</a> 是一个基于Node.js的开源静态博客程序，通过markdown书写文章，生成的静态网页可以托管在github及gitcafe上。通过<a href="https://hexo.io/">Hexo</a>可以方便的创建自己的博客，本博客即使用Hexo创建并托管在github及gitcafe上。]]>
    
    </summary>
    
      <category term="blog" scheme="https://libhappy.com/tags/blog/"/>
    
      <category term="hexo" scheme="https://libhappy.com/tags/hexo/"/>
    
      <category term="静态博客" scheme="https://libhappy.com/tags/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Hexo" scheme="https://libhappy.com/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python中的super使用]]></title>
    <link href="https://libhappy.com/2015/08/python-usage-super/"/>
    <id>https://libhappy.com/2015/08/python-usage-super/</id>
    <published>2015-08-16T01:46:43.000Z</published>
    <updated>2016-03-16T09:56:36.000Z</updated>
    <content type="html"><![CDATA[<p>Python中子类要调用父类的方法（method），在python2.2之前通常的写法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__inti__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"enter A"</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"leave A"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"enter B"</span></span><br><span class="line">        A.__init__(self)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"leave B"</span></span><br></pre></td></tr></table></figure>
<p>即使用非绑定的类方法（用类名来引用），并在参数列表中引入待绑定的对象（self），从而达到调用父类的目的。这样做的缺点是，当一个子类的父类发生变化时（如类B的父类由A变为C时），必须遍历整个类定义，把所有的通过非绑定的方法的类名全部替换过来。</p>
<p>自python2.2开始，python添加了一个关键字<strong>super</strong>来解决这个问题。官方说明如下：
<a id="more"></a></p>
<blockquote>
<p>super(type[, object-or-type])</p>
<p>Return the superclass of type. If the second argument is omitted the super object returned is unbound. If the second argument is an object,  isinstance(obj, type) must be true. If the second argument is a type, issubclass(type2, type) must be true. super() only works for new-style classes.</p>
<p>A typical use for calling a cooperative superclass method is:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(B)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">meth</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        super(C, self).meth(arg)</span><br></pre></td></tr></table></figure>
<p>New in version 2.2.</p>
</blockquote>
<p>因此改写后的类B代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span>    <span class="comment"># A must be new-style class</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"enter A"</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"leave A"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(C)</span>:</span>     <span class="comment"># A --&gt; C</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"enter B"</span></span><br><span class="line">        super(B, self).__init__()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"leave B"</span></span><br></pre></td></tr></table></figure>
<p>其运行结果与第一种方法一致。</p>
<hr>
<p>super的引入同时也解决了涉及多继承情况时父类的多次调用问题，考虑如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">         <span class="keyword">print</span> <span class="string">"Enter A"</span></span><br><span class="line">         <span class="keyword">print</span> <span class="string">"Leave A"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Enter B"</span></span><br><span class="line">        A.__init__(self)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Leave B"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Enter C"</span></span><br><span class="line">        A.__init__(self)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Leave C"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Enter D"</span></span><br><span class="line">        A.__init__(self)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Leave D"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span><span class="params">(B, C, D)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Enter E"</span></span><br><span class="line">        B.__init__(self)</span><br><span class="line">        C.__init__(self)</span><br><span class="line">        D.__init__(self)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Leave E"</span></span><br><span class="line"></span><br><span class="line">e = E()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter E&#10;Enter B&#10;Enter A&#10;Leave A&#10;Leave B&#10;Enter C&#10;Enter A&#10;Leave A&#10;Leave C&#10;Enter D&#10;Enter A&#10;Leave A&#10;Leave D&#10;Leave E</span><br></pre></td></tr></table></figure>
<p>其中公共父类A被执行了多次。
将其中的类名引用换为super:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">         <span class="keyword">print</span> <span class="string">"Enter A"</span></span><br><span class="line">         <span class="keyword">print</span> <span class="string">"Leave A"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Enter B"</span></span><br><span class="line">        super(B, self)__init__()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Leave B"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Enter C"</span></span><br><span class="line">        super(C, self)__init__()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Leave C"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Enter D"</span></span><br><span class="line">        super(D, self)__init__()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Leave D"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span><span class="params">(B, C, D)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Enter E"</span></span><br><span class="line">        super(E, self)__init__()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Leave E"</span></span><br><span class="line"></span><br><span class="line">e = E()</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter E&#10;Enter B&#10;Enter C&#10;Enter D&#10;Enter A&#10;Leave A&#10;Leave D&#10;Leave C&#10;Leave B&#10;Leave E</span><br></pre></td></tr></table></figure>
<p>在super机制中能够保证公共父类仅被执行一次，且执行的顺序按照MRO进行（E.__mro__）。</p>
<hr>
<p>super在使用中有下列需要注意的地方：</p>
<ol>
<li>super并不是一个函数，是一个类名，形如super(B, self)事实上调用了super类的初始化函数，产生了一个super对象；</li>
<li>super类的初始化函数并没有做什么特殊的操作，只是简单记录了类类型和具体实例；</li>
<li>super(B, self).func的调用并不是用于调用当前类的父类的func函数；</li>
<li>Python的多继承类是通过mro的方式来保证各个父类的函数被逐一调用，而且保证每个父类函数只调用一次（如果每个类都使用super）；</li>
<li>混用super类和非绑定的函数是一个危险行为，这可能导致应该调用的父类函数没有调用或者一个父类函数被调用多次。</li>
</ol>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="http://www.jb51.net/article/66912.htm" title="Python 中的super用法详解" target="_blank" rel="external">Python 中的super用法详解</a></li>
<li><a href="http://www.cnblogs.com/dkblog/archive/2011/02/24/1980654.html" title="关于Python的super用法研究" target="_blank" rel="external">关于Python的super用法研究</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Python中子类要调用父类的方法（method），在python2.2之前通常的写法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__inti__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"enter A"</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"leave A"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"enter B"</span></span><br><span class="line">        A.__init__(self)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"leave B"</span></span><br></pre></td></tr></table></figure>
<p>即使用非绑定的类方法（用类名来引用），并在参数列表中引入待绑定的对象（self），从而达到调用父类的目的。这样做的缺点是，当一个子类的父类发生变化时（如类B的父类由A变为C时），必须遍历整个类定义，把所有的通过非绑定的方法的类名全部替换过来。</p>
<p>自python2.2开始，python添加了一个关键字<strong>super</strong>来解决这个问题。官方说明如下：]]>
    
    </summary>
    
      <category term="python" scheme="https://libhappy.com/tags/python/"/>
    
      <category term="super" scheme="https://libhappy.com/tags/super/"/>
    
      <category term="Python" scheme="https://libhappy.com/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python 类的多重继承]]></title>
    <link href="https://libhappy.com/2015/08/python-class-re-order/"/>
    <id>https://libhappy.com/2015/08/python-class-re-order/</id>
    <published>2015-08-15T08:14:10.000Z</published>
    <updated>2016-01-14T06:36:28.000Z</updated>
    <content type="html"><![CDATA[<p>Python 的类分为经典类与新式类。Python2.7之前的版本中可以采用经典类，经典类继承父类的顺序采用深度优先算法，但在Python3之后的版本就只承认新式类了。新式类在python2.2之后的版本中都可以使用，新式类的继承顺序采用C3算法，其继承顺序可以通过查看MRO列表获取。
<a id="more"></a>
<!--toc--></p>
<h1 id="经典类与新式类的区别">经典类与新式类的区别</h1><ol>
<li><p>经典类是默认没有派生自某个基类的，而新式类默认派生自<code>object</code>基类：</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># old style</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># new style</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>经典类在类多重继承的时候是采用的从左至右深度优先的匹配方法，而新式类采用C3算法（不同于广度优先）进行匹配的。</p>
</li>
<li><p>经典类没有<code>__MRO__</code>和<code>instance.mro()</code>调用，而新式类有。</p>
</li>
</ol>
<h1 id="经典类中的继承问题">经典类中的继承问题</h1><p>经典类中采用<strong>深度优先</strong>的匹配方法，可能导致在查询继承树中绕过后面的父类：
<!--more-->
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"class D"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(D)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(D)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"class C"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(B, C)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">f = A()</span><br><span class="line">f.foo()</span><br></pre></td></tr></table></figure></p>
<p>其输出为：class D。
新式类采用<strong>C3算法</strong>（区别于<strong>广度优先</strong>的原则）进行搜索，若使用新式类：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"class D"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(D)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(D)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"class C"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(B, C)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">f = A()</span><br><span class="line">f.foo()</span><br></pre></td></tr></table></figure></p>
<p>输出为：class C
搜索的顺序如下图所示：</p>
<div class="figure center nocaption"><a class="fancybox" href="https://farm1.staticflickr.com/678/21780464824_b470a6eab4.jpg" title="Python中类的方法解析顺序" target="_blank" rel="external"><img class="fig-img" src="https://farm1.staticflickr.com/678/21780464824_b470a6eab4.jpg" alt="Python中类的方法解析顺序"></a></div>
<h1 id="C3算法">C3算法</h1><p><strong>C3算法</strong>最早被提出是用于Lisp的，应用在Python中是为了解决原来基于深度优先搜索算法不满足本地优先级，和单调性的问题。</p>
<ul>
<li><strong>本地优先级</strong>：指声明时父类的顺序，比如C(A,B)，如果访问C类对象属性时，应该根据声明顺序，优先查找A类，然后再查找B类。</li>
<li><strong>单调性</strong>：如果在C的解析顺序中，A排在B的前面，那么在C的所有子类里，也必须满足这个顺序。</li>
</ul>
<p><strong>深度优先搜索</strong>用栈（stack）来实现，整个过程可以想象成一个倒立的树形：</p>
<ol>
<li>把根节点压入栈中。</li>
<li>每次从栈中弹出一个元素，搜索所有在它下一级的元素，把这些元素压入栈中。并把这个元素记为它下一级元素的前驱。</li>
<li>找到所要找的元素时结束程序。</li>
<li>如果遍历整个树还没有找到，结束程序。</li>
</ol>
<p><strong>广度优先搜索</strong>使用队列（queue）来实现，整个过程也可以看做一个倒立的树形：</p>
<ol>
<li>把根节点放到队列的末尾。</li>
<li>每次从队列的头部取出一个元素，查看这个元素所有的下一级元素，把它们放到队列的末尾。并把这个元素记为它下一级元素的前驱。</li>
<li>找到所要找的元素时结束程序。</li>
<li>如果遍历整个树还没有找到，结束程序。</li>
</ol>
<p>对于同一段程序：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"A"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"B"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(B)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"C"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"D"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span><span class="params">(D)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"E"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span><span class="params">(C, E)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"F"</span></span><br><span class="line"></span><br><span class="line">f = F()</span><br><span class="line">f.foo1()</span><br></pre></td></tr></table></figure></p>
<p>当使用深度优先搜索，广度优先搜索及C3算法的不同搜索顺序如下：</p>
<div class="figure fig-33"><a class="fancybox" href="https://farm1.staticflickr.com/592/21782098993_467910d598.jpg" title="DFS深度优先搜索(FCBAED)" target="_blank" rel="external"><img class="fig-img" src="https://farm1.staticflickr.com/592/21782098993_467910d598_n.jpg" alt="DFS深度优先搜索(FCBAED)"></a><span class="caption">DFS深度优先搜索(FCBAED)</span></div>
<div class="figure fig-33"><a class="fancybox" href="https://farm1.staticflickr.com/651/22215216660_42133913bb.jpg" title="BFS广度优先搜索(FCEBDA)" target="_blank" rel="external"><img class="fig-img" src="https://farm1.staticflickr.com/651/22215216660_42133913bb_n.jpg" alt="BFS广度优先搜索(FCEBDA)"></a><span class="caption">BFS广度优先搜索(FCEBDA)</span></div>
<div class="figure fig-33"><a class="fancybox" href="https://farm1.staticflickr.com/661/22215486608_17a874a876.jpg" title="C3算法(FCBEDA)" target="_blank" rel="external"><img class="fig-img" src="https://farm1.staticflickr.com/661/22215486608_17a874a876_n.jpg" alt="C3算法(FCBEDA)"></a><span class="caption">C3算法(FCBEDA)</span></div><div style="clear:both;"></div>
<p>对于新式类，可以用<code>instance.__mro__</code>或<code>instance.mro()</code>来查看其MRO（Method Resolution Order 方法解析顺序）列表。对于上文代码中的类<code>F</code>的MRO如下：
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print F.mro()</span><br><span class="line">(&lt;class '__main__.F'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.E'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.A'&gt;, &lt;type 'object'&gt;)</span><br></pre></td></tr></table></figure></p>
<p>即C3算法的解析结果。
同时为了解决多重继承中的调用父类问题，python2.2之后引入了<code>super</code>。</p>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="http://python-history.blogspot.com/2010/06/method-resolution-order.html" title="Method Resolution Order" target="_blank" rel="external">Method Resolution Order</a></li>
<li><a href="http://www.jb51.net/article/57263.htm" title="Python类的多重继承问题深入分析" target="_blank" rel="external">Python类的多重继承问题深入分析</a></li>
<li><a href="http://blog.csdn.net/imzoer/article/details/8737642" title="python类学习以及mro--多继承属性查找机制 " target="_blank" rel="external">python类学习以及mro–多继承属性查找机制 </a></li>
<li><a href="http://demo.netfoucs.com/icode0410/article/details/39400233" title="Python 类继承，__bases__, __mro__, super " target="_blank" rel="external">Python 类继承，__bases__, __mro__, super </a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Python 的类分为经典类与新式类。Python2.7之前的版本中可以采用经典类，经典类继承父类的顺序采用深度优先算法，但在Python3之后的版本就只承认新式类了。新式类在python2.2之后的版本中都可以使用，新式类的继承顺序采用C3算法，其继承顺序可以通过查看MRO列表获取。]]>
    
    </summary>
    
      <category term="class" scheme="https://libhappy.com/tags/class/"/>
    
      <category term="python" scheme="https://libhappy.com/tags/python/"/>
    
      <category term="继承" scheme="https://libhappy.com/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="Python" scheme="https://libhappy.com/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编写第一个PyQt4程序]]></title>
    <link href="https://libhappy.com/2015/07/pyqt4-tutorial-01/"/>
    <id>https://libhappy.com/2015/07/pyqt4-tutorial-01/</id>
    <published>2015-07-07T09:30:17.000Z</published>
    <updated>2016-01-29T05:14:57.000Z</updated>
    <content type="html"><![CDATA[<p>PyQt是Qt库的Python版本，该教程是 <a href="http://zetcode.com/gui/pyqt4/" target="_blank" rel="external">zetcode</a> PyQt4教程的中文翻译。
本文主要介绍了PyQt4的基本使用方法及基本窗口的绘制。
<a id="more"></a>
<!--toc--></p>
<h1 id="简单示例">简单示例</h1><p>第一个程序显示一个简单的窗口。
以下是原始代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">Created on Sat Jul 04 21:23:31 2015</span><br><span class="line"></span><br><span class="line">@author: Arthur</span><br><span class="line">an example for PyQt4 gui program.</span><br><span class="line">"""</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt4 <span class="keyword">import</span> QtGui    <span class="comment"># 导入必要的模块</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    app = QtGui.QApplication(sys.argv)   <span class="comment"># 创建一个应用对象，sys.argv为命令行传入的参数</span></span><br><span class="line"></span><br><span class="line">    window = QtGui.QWidget() <span class="comment"># QtGui.Qwidget 是所有界面对象的基础类，没有父类的部件称为窗口</span></span><br><span class="line">    window.resize(<span class="number">250</span>, <span class="number">150</span>) <span class="comment"># 调整部件大小，250px宽150px高</span></span><br><span class="line">    window.move(<span class="number">300</span>, <span class="number">300</span>)  <span class="comment"># 移动部件的位置到屏幕 (x = 300, y = 300)处</span></span><br><span class="line">    window.setWindowTitle(<span class="string">'Simple'</span>) <span class="comment"># 设置窗口标题栏显示的标题</span></span><br><span class="line">    window.show() <span class="comment"># 在内存中创建组件并显示在屏幕上</span></span><br><span class="line"></span><br><span class="line">    sys.exit(app.exec_()) <span class="comment"># sys.exit()保证程序完全的退出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>显示窗口如下：</p>
<div class="figure center"><img class="fig-img" src="https://farm6.staticflickr.com/5793/22215503798_0382018900.jpg" alt="简单的窗口"><span class="caption">简单的窗口</span></div>
<h1 id="添加应用图标(Application_icon)">添加应用图标(Application icon)</h1><p>添加在标题栏左上角显示的应用图标，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">Created on Sat Jul 04 21:54:19 2015</span><br><span class="line"></span><br><span class="line">@author: Arthur</span><br><span class="line">A gui program with application icon.</span><br><span class="line">use OOP(Object Oriented Programming)</span><br><span class="line">"""</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt4 <span class="keyword">import</span> QtGui</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span><span class="params">(QtGui.QWidget)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Example, self).__init__() <span class="comment"># super() method 返回对象'Example'的父类</span></span><br><span class="line"></span><br><span class="line">        self.initUI()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initUI</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.setGeometry(<span class="number">300</span>, <span class="number">300</span>, <span class="number">250</span>, <span class="number">150</span>) <span class="comment"># 设置窗口的坐标及大小(x, y, 宽, 高)</span></span><br><span class="line">        self.setWindowTitle(<span class="string">'Icon'</span>)</span><br><span class="line">        self.setWindowIcon(QtGui.QIcon(<span class="string">'web.png'</span>)) <span class="comment"># 设置窗口应用图标</span></span><br><span class="line"></span><br><span class="line">        self.show()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    app = QtGui.QApplication(sys.argv)</span><br><span class="line">    ex = Example()</span><br><span class="line">    sys.exit(app.exec_())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>该程序以面向对象的风格书写，面向对象编程中最重要的是类(class)，数据(data)和方法(method)。显示的窗口如下：</p>
<div class="figure center"><img class="fig-img" src="https://farm6.staticflickr.com/5710/22215504998_90237dc62c.jpg" alt="在标题栏显示程序图标"><span class="caption">在标题栏显示程序图标</span></div>
<hr>
<h1 id="显示提示信息">显示提示信息</h1><p>显示部件的气球帮助提示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">Created on Sun Jul 05 11:40:30 2015</span><br><span class="line"></span><br><span class="line">@author: Arthur</span><br><span class="line">show a tooltip</span><br><span class="line">"""</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt4 <span class="keyword">import</span> QtGui</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span><span class="params">(QtGui.QWidget)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Example, self).__init__()</span><br><span class="line">        self.initUI()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initUI</span><span class="params">(self)</span>:</span></span><br><span class="line">        QtGui.QToolTip.setFont(QtGui.QFont(<span class="string">'SansSerif'</span>, <span class="number">10</span>)) <span class="comment"># 设置提示的字形及字体大小</span></span><br><span class="line">        self.setToolTip(<span class="string">'This is a &lt;b&gt;QWidget&lt;/b&gt; widget'</span>)</span><br><span class="line"></span><br><span class="line">        btn = QtGui.QPushButton(<span class="string">'Button'</span>, self)</span><br><span class="line">        btn.setToolTip(<span class="string">'This is a &lt;b&gt;QPushButton&lt;/b&gt; widget'</span>)</span><br><span class="line">        btn.resize(btn.sizeHint())  <span class="comment"># szieHint() 返回按钮推荐的大小</span></span><br><span class="line">        btn.move(<span class="number">50</span>, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">        self.setGeometry(<span class="number">300</span>, <span class="number">300</span>, <span class="number">250</span>, <span class="number">150</span>)</span><br><span class="line">        self.setWindowTitle(<span class="string">'Tooltips'</span>)</span><br><span class="line">        self.show()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    app = QtGui.QApplication(sys.argv)</span><br><span class="line">    ex = Example()</span><br><span class="line">    sys.exit(app.exec_())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>显示的窗口如下：</p>
<div class="figure center"><img class="fig-img" src="https://farm6.staticflickr.com/5814/22390057122_b69cfefa95.jpg" alt="创建有气泡提示的按钮"><span class="caption">创建有气泡提示的按钮</span></div>
<hr>
<h1 id="关闭窗口">关闭窗口</h1><p>以上的例子中都是通过点击窗口右上角的<code>X</code>来关闭窗口，下面的例子演示了通过程序内的方法关闭窗口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">Created on Sun Jul 05 12:24:44 2015</span><br><span class="line">@author: Arthur</span><br><span class="line">A button with quit</span><br><span class="line">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt4 <span class="keyword">import</span> QtGui, QtCore</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span><span class="params">(QtGui.QWidget)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Example, self).__init__()</span><br><span class="line">        self.initUI()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initUI</span><span class="params">(self)</span>:</span></span><br><span class="line">        qbtn = QtGui.QPushButton(<span class="string">'Quit'</span>, self) <span class="comment"># 参数分别为按钮的标签及按钮的父类</span></span><br><span class="line">        qbtn.clicked.connect(QtCore.QCoreApplication.instance().quit)</span><br><span class="line"></span><br><span class="line">        qbtn.resize(qbtn.sizeHint())</span><br><span class="line">        qbtn.move(<span class="number">50</span>, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">        self.setGeometry(<span class="number">300</span>, <span class="number">300</span>, <span class="number">250</span>, <span class="number">150</span>)</span><br><span class="line">        self.setWindowTitle(<span class="string">'Tooltips'</span>)</span><br><span class="line">        self.show()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    app = QtGui.QApplication(sys.argv)</span><br><span class="line">    ex = Example()</span><br><span class="line">    sys.exit(app.exec_())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>该程序创建了<code>QtGui.QPushButton</code>类的一个实例<code>qbtn</code>，在以下的语句中赋予了该按钮关闭程序的功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qbtn.clicked.connect(QtCore.QCoreApplication.instance().quit)</span><br></pre></td></tr></table></figure>
<div class="figure right"><img class="fig-img" src="https://farm1.staticflickr.com/565/22377226956_789c1b572a.jpg" alt="使程序退出的按钮"><span class="caption">使程序退出的按钮</span></div>
<p>PyQt4中的事件处理是由信号（signals）与槽（slots）机制实现的，如果点击按钮，将会发出<code>clicked()</code>的信号。槽可以是PyQt的槽或者是Python可调用的方法。通过使用<code>QtCore.QObject.connect()</code>方法将信号和槽链接起来。<code>QtCore.QCoreApplication</code> 包含了主要的事件循环，它处理和分配所有的事件。<code>instance()</code>方法返回它自己的实例。 应该注意的是<code>QtCore.QCoreApplication</code>同<code>QtGui.QApplication</code>一起被创建。点击信号连接到PyQt中预先定义的<code>quit()</code>槽。至此信号发送方与接收方之间的通信完成，发送方为点击按钮，接收方为程序对象。</p>
<hr>
<h1 id="消息框">消息框</h1><p>当点击窗口右上角<code>x</code>退出时弹出确认消息框。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">Created on Sun Jul 05 12:38:58 2015</span><br><span class="line">@author: Arthur</span><br><span class="line">show message box</span><br><span class="line">"""</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt4 <span class="keyword">import</span> QtGui</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span><span class="params">(QtGui.QWidget)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Example, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.initUI()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initUI</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.setGeometry(<span class="number">300</span>, <span class="number">300</span>, <span class="number">250</span>, <span class="number">150</span>)</span><br><span class="line">        self.setWindowTitle(<span class="string">'Message box'</span>)</span><br><span class="line">        self.show()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closeEvent</span><span class="params">(self, event)</span>:</span></span><br><span class="line">        reply = QtGui.QMessageBox.question(self, <span class="string">'Message'</span>,</span><br><span class="line">        <span class="string">"Are you sure to quit?"</span>, QtGui.QMessageBox.Yes |</span><br><span class="line">        QtGui.QMessageBox.No, QtGui.QMessageBox.No) <span class="comment"># (消息框标题, 显示消息, 选项 | 选项, 默认选项)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> reply == QtGui.QMessageBox.Yes:</span><br><span class="line">            event.accept()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            event.ignore()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    app = QtGui.QApplication(sys.argv)</span><br><span class="line">    ex = Example()</span><br><span class="line">    sys.exit(app.exec_())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<div class="figure center"><img class="fig-img" src="https://farm6.staticflickr.com/5678/22216388499_4a2df52106.jpg" alt="点击关闭后弹出确认消息框"><span class="caption">点击关闭后弹出确认消息框</span></div>
<div class="figure right"><img class="fig-img" src="https://farm6.staticflickr.com/5815/22377228426_c71f00748e_m.jpg" alt="确认关闭消息框"><span class="caption">确认关闭消息框</span></div>
<p>如果要关闭<code>QWidget</code>，<code>QCloseEvent</code>事件就会产生。要修改<code>QWidget</code>的默认行为，就需要重载父类中的<code>closeEvent()</code>方法。点击关闭按钮后，弹出如右对话框。
点击<code>Yes</code>或<code>No</code>后，对<code>replay</code>值进行比较，如果为<code>Yes</code>则接收事件关闭窗口，相反则忽略事件。</p>
<hr>
<h1 id="居中窗口">居中窗口</h1><p>在屏幕中央显示窗口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">Created on Sun Jul 05 14:42:27 2015</span><br><span class="line">@author: Arthur</span><br><span class="line">centering window on the screen</span><br><span class="line">"""</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt4 <span class="keyword">import</span> QtGui</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span><span class="params">(QtGui.QWidget)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Example, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.initUI()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initUI</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.resize(<span class="number">250</span>, <span class="number">150</span>)</span><br><span class="line">        self.center()</span><br><span class="line"></span><br><span class="line">        self.setWindowTitle(<span class="string">'Center'</span>)</span><br><span class="line">        self.show()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">center</span><span class="params">(self)</span>:</span></span><br><span class="line">        qr = self.frameGeometry() <span class="comment"># 返回代表窗口框架结构的矩形</span></span><br><span class="line">        cp = QtGui.QDesktopWidget().availableGeometry().center() <span class="comment"># 返回屏幕（可显示区域）的中心点</span></span><br><span class="line">        qr.moveCenter(cp) <span class="comment"># 将与窗口同大的矩形移动到屏幕中央</span></span><br><span class="line">        self.move(qr.topLeft())  <span class="comment"># 将主窗口移动到已定位的矩形处，QWidget的移动以左上角为基准点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    app = QtGui.QApplication(sys.argv)</span><br><span class="line">    ex = Example()</span><br><span class="line">    sys.exit(app.exec_())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>通过<code>frameGeometry()</code>获得代表窗口框架结构的矩形，通过<code>availableGeometry().center()</code>获得屏幕（可显示区域）的中心点，用<code>moveCenter()</code>方法将该框架矩形移动到屏幕中央，再将主窗口移动到已定位的矩形处。
由于移动窗口组件时是以组件的右上角为基准点，所以不能用<del><code>self.move(cp)</code></del>移动窗口到中心。
也可以在获得屏幕与窗口几何参数后直接移动窗口的左上角到计算出的目的位置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">screen = QtGui.QDesktopWidget().screenGeometry() <span class="comment"># 获得屏幕形状参数</span></span><br><span class="line">size = self.geometry() <span class="comment"># 获得窗口形状参数</span></span><br><span class="line">self.move((screen.width() - size.width()) / <span class="number">2</span>, (screen.height() - size.height()) / <span class="number">2</span>) <span class="comment"># 计算出窗口左上角移动后的位置，再直接移动窗口</span></span><br></pre></td></tr></table></figure>
<hr>
<p>参考资料：</p>
<ol>
<li>First Program in PyQt4 from <a href="http://zetcode.com/gui/pyqt4/firstprograms/" title="First Program" target="_blank" rel="external">zetcode</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>PyQt是Qt库的Python版本，该教程是 <a href="http://zetcode.com/gui/pyqt4/">zetcode</a> PyQt4教程的中文翻译。
本文主要介绍了PyQt4的基本使用方法及基本窗口的绘制。]]>
    
    </summary>
    
      <category term="pyqt4" scheme="https://libhappy.com/tags/pyqt4/"/>
    
      <category term="python" scheme="https://libhappy.com/tags/python/"/>
    
      <category term="zetcode" scheme="https://libhappy.com/tags/zetcode/"/>
    
      <category term="PyQt4" scheme="https://libhappy.com/categories/PyQt4/"/>
    
  </entry>
  
</feed>
